/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "ca_ca_types.h"
#include <thrift/c_glib/thrift.h>

enum _caCAParamterProperties
{
  PROP_CA_C_A_PARAMTER_0,
  PROP_CA_C_A_PARAMTER_PUB,
  PROP_CA_C_A_PARAMTER_MSK
};

/* reads a c_a_paramter object */
static gint32
ca_c_a_paramter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCAParamter * this_object = CA_C_A_PARAMTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->msk != NULL)
          {
            g_free(this_object->msk);
            this_object->msk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->msk = g_byte_array_new();
          g_byte_array_append (this_object->msk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_msk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_c_a_paramter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCAParamter * this_object = CA_C_A_PARAMTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CAParamter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "msk", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->msk ? ((GByteArray *) this_object->msk)->data : NULL, this_object->msk ? ((GByteArray *) this_object->msk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_c_a_paramter_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  caCAParamter *self = CA_C_A_PARAMTER (object);

  switch (property_id)
  {
    case PROP_CA_C_A_PARAMTER_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_CA_C_A_PARAMTER_MSK:
      if (self->msk != NULL)
        g_byte_array_unref (self->msk);
      self->msk = g_value_dup_boxed (value);
      self->__isset_msk = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_c_a_paramter_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  caCAParamter *self = CA_C_A_PARAMTER (object);

  switch (property_id)
  {
    case PROP_CA_C_A_PARAMTER_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_CA_C_A_PARAMTER_MSK:
      g_value_set_boxed (value, self->msk);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_c_a_paramter_instance_init (caCAParamter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->msk = NULL;
  object->__isset_msk = FALSE;
}

static void 
ca_c_a_paramter_finalize (GObject *object)
{
  caCAParamter *tobject = CA_C_A_PARAMTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->msk != NULL)
  {
    thrift_string_free(tobject->msk);
    tobject->msk = NULL;
  }
}

static void
ca_c_a_paramter_class_init (caCAParamterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_c_a_paramter_read;
  struct_class->write = ca_c_a_paramter_write;

  gobject_class->finalize = ca_c_a_paramter_finalize;
  gobject_class->get_property = ca_c_a_paramter_get_property;
  gobject_class->set_property = ca_c_a_paramter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_C_A_PARAMTER_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_C_A_PARAMTER_MSK,
     g_param_spec_boxed ("msk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
ca_c_a_paramter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCAParamterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_c_a_paramter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCAParamter),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_c_a_paramter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCAParamterType",
                                   &type_info, 0);
  }

  return type;
}

enum _caUserRegisterProperties
{
  PROP_CA_USER_REGISTER_0,
  PROP_CA_USER_REGISTER_GPK,
  PROP_CA_USER_REGISTER_GSK,
  PROP_CA_USER_REGISTER_USER_CERT,
  PROP_CA_USER_REGISTER_ATTRIBUTES,
  PROP_CA_USER_REGISTER_UID
};

/* reads a user_register object */
static gint32
ca_user_register_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caUserRegister * this_object = CA_USER_REGISTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->gpk != NULL)
          {
            g_free(this_object->gpk);
            this_object->gpk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->gpk = g_byte_array_new();
          g_byte_array_append (this_object->gpk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_gpk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->gsk != NULL)
          {
            g_free(this_object->gsk);
            this_object->gsk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->gsk = g_byte_array_new();
          g_byte_array_append (this_object->gsk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_gsk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->UserCert != NULL)
          {
            g_free(this_object->UserCert);
            this_object->UserCert = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->UserCert = g_byte_array_new();
          g_byte_array_append (this_object->UserCert, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_UserCert = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem0 = NULL;
              if (_elem0 != NULL)
              {
                g_free(_elem0);
                _elem0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->uid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_uid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_user_register_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caUserRegister * this_object = CA_USER_REGISTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserRegister", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "gpk", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->gpk ? ((GByteArray *) this_object->gpk)->data : NULL, this_object->gpk ? ((GByteArray *) this_object->gpk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "gsk", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->gsk ? ((GByteArray *) this_object->gsk)->data : NULL, this_object->gsk ? ((GByteArray *) this_object->gsk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "UserCert", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->UserCert ? ((GByteArray *) this_object->UserCert)->data : NULL, this_object->UserCert ? ((GByteArray *) this_object->UserCert)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < (this_object->attributes ? this_object->attributes->len : 0); i1++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i1)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uid", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->uid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_user_register_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  caUserRegister *self = CA_USER_REGISTER (object);

  switch (property_id)
  {
    case PROP_CA_USER_REGISTER_GPK:
      if (self->gpk != NULL)
        g_byte_array_unref (self->gpk);
      self->gpk = g_value_dup_boxed (value);
      self->__isset_gpk = TRUE;
      break;

    case PROP_CA_USER_REGISTER_GSK:
      if (self->gsk != NULL)
        g_byte_array_unref (self->gsk);
      self->gsk = g_value_dup_boxed (value);
      self->__isset_gsk = TRUE;
      break;

    case PROP_CA_USER_REGISTER_USER_CERT:
      if (self->UserCert != NULL)
        g_byte_array_unref (self->UserCert);
      self->UserCert = g_value_dup_boxed (value);
      self->__isset_UserCert = TRUE;
      break;

    case PROP_CA_USER_REGISTER_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_CA_USER_REGISTER_UID:
      self->uid = g_value_get_int (value);
      self->__isset_uid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_user_register_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  caUserRegister *self = CA_USER_REGISTER (object);

  switch (property_id)
  {
    case PROP_CA_USER_REGISTER_GPK:
      g_value_set_boxed (value, self->gpk);
      break;

    case PROP_CA_USER_REGISTER_GSK:
      g_value_set_boxed (value, self->gsk);
      break;

    case PROP_CA_USER_REGISTER_USER_CERT:
      g_value_set_boxed (value, self->UserCert);
      break;

    case PROP_CA_USER_REGISTER_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_CA_USER_REGISTER_UID:
      g_value_set_int (value, self->uid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_user_register_instance_init (caUserRegister * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->gpk = NULL;
  object->__isset_gpk = FALSE;
  object->gsk = NULL;
  object->__isset_gsk = FALSE;
  object->UserCert = NULL;
  object->__isset_UserCert = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
  object->uid = 0;
  object->__isset_uid = FALSE;
}

static void 
ca_user_register_finalize (GObject *object)
{
  caUserRegister *tobject = CA_USER_REGISTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->gpk != NULL)
  {
    thrift_string_free(tobject->gpk);
    tobject->gpk = NULL;
  }
  if (tobject->gsk != NULL)
  {
    thrift_string_free(tobject->gsk);
    tobject->gsk = NULL;
  }
  if (tobject->UserCert != NULL)
  {
    thrift_string_free(tobject->UserCert);
    tobject->UserCert = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
ca_user_register_class_init (caUserRegisterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_user_register_read;
  struct_class->write = ca_user_register_write;

  gobject_class->finalize = ca_user_register_finalize;
  gobject_class->get_property = ca_user_register_get_property;
  gobject_class->set_property = ca_user_register_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_USER_REGISTER_GPK,
     g_param_spec_boxed ("gpk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_USER_REGISTER_GSK,
     g_param_spec_boxed ("gsk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_USER_REGISTER_USER_CERT,
     g_param_spec_boxed ("UserCert",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_USER_REGISTER_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_USER_REGISTER_UID,
     g_param_spec_int ("uid",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
ca_user_register_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caUserRegisterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_user_register_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caUserRegister),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_user_register_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caUserRegisterType",
                                   &type_info, 0);
  }

  return type;
}

enum _caURevoKeyProperties
{
  PROP_CA_U_REVO_KEY_0,
  PROP_CA_U_REVO_KEY_M,
  PROP_CA_U_REVO_KEY_K0,
  PROP_CA_U_REVO_KEY_K1,
  PROP_CA_U_REVO_KEY_K2,
  PROP_CA_U_REVO_KEY_K_J,
  PROP_CA_U_REVO_KEY_KIJX,
  PROP_CA_U_REVO_KEY_ATTRIBUTES
};

/* reads a u_revo_key object */
static gint32
ca_u_revo_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caURevoKey * this_object = CA_U_REVO_KEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->m, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_m = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->K0 != NULL)
          {
            g_free(this_object->K0);
            this_object->K0 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->K0 = g_byte_array_new();
          g_byte_array_append (this_object->K0, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_K0 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->K1 != NULL)
          {
            g_free(this_object->K1);
            this_object->K1 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->K1 = g_byte_array_new();
          g_byte_array_append (this_object->K1, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_K1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->K2 != NULL)
          {
            g_free(this_object->K2);
            this_object->K2 = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->K2 = g_byte_array_new();
          g_byte_array_append (this_object->K2, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_K2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->KJ != NULL)
          {
            g_free(this_object->KJ);
            this_object->KJ = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->KJ = g_byte_array_new();
          g_byte_array_append (this_object->KJ, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_KJ = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key2 = NULL;
              GByteArray * val3 = NULL;
              if (key2 != NULL)
              {
                g_free(key2);
                key2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key2, error)) < 0)
                return -1;
              xfer += ret;
              if (val3 != NULL)
              {
                g_free(val3);
                val3 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val3 = g_byte_array_new();
              g_byte_array_append (val3, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->Kijx && key2)
                g_hash_table_insert ((GHashTable *)this_object->Kijx, (gpointer) key2, (gpointer) val3);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_Kijx = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem4 = NULL;
              if (_elem4 != NULL)
              {
                g_free(_elem4);
                _elem4 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem4, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_u_revo_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caURevoKey * this_object = CA_U_REVO_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "URevoKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "m", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->m, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "K0", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->K0 ? ((GByteArray *) this_object->K0)->data : NULL, this_object->K0 ? ((GByteArray *) this_object->K0)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "K1", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->K1 ? ((GByteArray *) this_object->K1)->data : NULL, this_object->K1 ? ((GByteArray *) this_object->K1)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "K2", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->K2 ? ((GByteArray *) this_object->K2)->data : NULL, this_object->K2 ? ((GByteArray *) this_object->K2)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "KJ", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->KJ ? ((GByteArray *) this_object->KJ)->data : NULL, this_object->KJ ? ((GByteArray *) this_object->KJ)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "Kijx", T_MAP, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key5 = NULL;
    GByteArray * val6 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->Kijx ? (gint32) g_hash_table_size ((GHashTable *) this_object->Kijx) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->Kijx)
      g_hash_table_foreach ((GHashTable *) this_object->Kijx, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key5 = keys[i];
      val6 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->Kijx), (gpointer) key5);

      if ((ret = thrift_protocol_write_string (protocol,  key5, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val6 ? ((GByteArray *)  val6)->data : NULL,  val6 ? ((GByteArray *)  val6)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i7;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i7 = 0; i7 < (this_object->attributes ? this_object->attributes->len : 0); i7++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i7)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_u_revo_key_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  caURevoKey *self = CA_U_REVO_KEY (object);

  switch (property_id)
  {
    case PROP_CA_U_REVO_KEY_M:
      self->m = g_value_get_int (value);
      self->__isset_m = TRUE;
      break;

    case PROP_CA_U_REVO_KEY_K0:
      if (self->K0 != NULL)
        g_byte_array_unref (self->K0);
      self->K0 = g_value_dup_boxed (value);
      self->__isset_K0 = TRUE;
      break;

    case PROP_CA_U_REVO_KEY_K1:
      if (self->K1 != NULL)
        g_byte_array_unref (self->K1);
      self->K1 = g_value_dup_boxed (value);
      self->__isset_K1 = TRUE;
      break;

    case PROP_CA_U_REVO_KEY_K2:
      if (self->K2 != NULL)
        g_byte_array_unref (self->K2);
      self->K2 = g_value_dup_boxed (value);
      self->__isset_K2 = TRUE;
      break;

    case PROP_CA_U_REVO_KEY_K_J:
      if (self->KJ != NULL)
        g_byte_array_unref (self->KJ);
      self->KJ = g_value_dup_boxed (value);
      self->__isset_KJ = TRUE;
      break;

    case PROP_CA_U_REVO_KEY_KIJX:
      if (self->Kijx != NULL)
        g_hash_table_unref (self->Kijx);
      self->Kijx = g_value_dup_boxed (value);
      self->__isset_Kijx = TRUE;
      break;

    case PROP_CA_U_REVO_KEY_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_u_revo_key_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  caURevoKey *self = CA_U_REVO_KEY (object);

  switch (property_id)
  {
    case PROP_CA_U_REVO_KEY_M:
      g_value_set_int (value, self->m);
      break;

    case PROP_CA_U_REVO_KEY_K0:
      g_value_set_boxed (value, self->K0);
      break;

    case PROP_CA_U_REVO_KEY_K1:
      g_value_set_boxed (value, self->K1);
      break;

    case PROP_CA_U_REVO_KEY_K2:
      g_value_set_boxed (value, self->K2);
      break;

    case PROP_CA_U_REVO_KEY_K_J:
      g_value_set_boxed (value, self->KJ);
      break;

    case PROP_CA_U_REVO_KEY_KIJX:
      g_value_set_boxed (value, self->Kijx);
      break;

    case PROP_CA_U_REVO_KEY_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_u_revo_key_instance_init (caURevoKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->m = 0;
  object->__isset_m = FALSE;
  object->K0 = NULL;
  object->__isset_K0 = FALSE;
  object->K1 = NULL;
  object->__isset_K1 = FALSE;
  object->K2 = NULL;
  object->__isset_K2 = FALSE;
  object->KJ = NULL;
  object->__isset_KJ = FALSE;
  object->Kijx = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_Kijx = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
}

static void 
ca_u_revo_key_finalize (GObject *object)
{
  caURevoKey *tobject = CA_U_REVO_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->K0 != NULL)
  {
    thrift_string_free(tobject->K0);
    tobject->K0 = NULL;
  }
  if (tobject->K1 != NULL)
  {
    thrift_string_free(tobject->K1);
    tobject->K1 = NULL;
  }
  if (tobject->K2 != NULL)
  {
    thrift_string_free(tobject->K2);
    tobject->K2 = NULL;
  }
  if (tobject->KJ != NULL)
  {
    thrift_string_free(tobject->KJ);
    tobject->KJ = NULL;
  }
  if (tobject->Kijx != NULL)
  {
    g_hash_table_destroy (tobject->Kijx);
    tobject->Kijx = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
ca_u_revo_key_class_init (caURevoKeyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_u_revo_key_read;
  struct_class->write = ca_u_revo_key_write;

  gobject_class->finalize = ca_u_revo_key_finalize;
  gobject_class->get_property = ca_u_revo_key_get_property;
  gobject_class->set_property = ca_u_revo_key_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_M,
     g_param_spec_int ("m",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_K0,
     g_param_spec_boxed ("K0",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_K1,
     g_param_spec_boxed ("K1",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_K2,
     g_param_spec_boxed ("K2",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_K_J,
     g_param_spec_boxed ("KJ",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_KIJX,
     g_param_spec_boxed ("Kijx",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_U_REVO_KEY_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
ca_u_revo_key_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caURevoKeyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_u_revo_key_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caURevoKey),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_u_revo_key_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caURevoKeyType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _caCenterCasetupArgsProperties
{
  PROP_CA_CENTER_CASETUP_ARGS_0,
  PROP_CA_CENTER_CASETUP_ARGS_N,
  PROP_CA_CENTER_CASETUP_ARGS_BYTESIZE
};

/* reads a center_casetup_args object */
static gint32
ca_center_casetup_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCenterCasetupArgs * this_object = CA_CENTER_CASETUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->N, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_N = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->bytesize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bytesize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_center_casetup_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCenterCasetupArgs * this_object = CA_CENTER_CASETUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CenterCasetupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "N", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->N, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bytesize", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->bytesize, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_center_casetup_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  caCenterCasetupArgs *self = CA_CENTER_CASETUP_ARGS (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CASETUP_ARGS_N:
      self->N = g_value_get_int (value);
      self->__isset_N = TRUE;
      break;

    case PROP_CA_CENTER_CASETUP_ARGS_BYTESIZE:
      self->bytesize = g_value_get_int (value);
      self->__isset_bytesize = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_center_casetup_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  caCenterCasetupArgs *self = CA_CENTER_CASETUP_ARGS (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CASETUP_ARGS_N:
      g_value_set_int (value, self->N);
      break;

    case PROP_CA_CENTER_CASETUP_ARGS_BYTESIZE:
      g_value_set_int (value, self->bytesize);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_center_casetup_args_instance_init (caCenterCasetupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->N = 0;
  object->__isset_N = FALSE;
  object->bytesize = 0;
  object->__isset_bytesize = FALSE;
}

static void 
ca_center_casetup_args_finalize (GObject *object)
{
  caCenterCasetupArgs *tobject = CA_CENTER_CASETUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
ca_center_casetup_args_class_init (caCenterCasetupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_center_casetup_args_read;
  struct_class->write = ca_center_casetup_args_write;

  gobject_class->finalize = ca_center_casetup_args_finalize;
  gobject_class->get_property = ca_center_casetup_args_get_property;
  gobject_class->set_property = ca_center_casetup_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CASETUP_ARGS_N,
     g_param_spec_int ("N",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CASETUP_ARGS_BYTESIZE,
     g_param_spec_int ("bytesize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
ca_center_casetup_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCenterCasetupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_center_casetup_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCenterCasetupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_center_casetup_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCenterCasetupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _caCenterCasetupResultProperties
{
  PROP_CA_CENTER_CASETUP_RESULT_0,
  PROP_CA_CENTER_CASETUP_RESULT_SUCCESS
};

/* reads a center_casetup_result object */
static gint32
ca_center_casetup_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCenterCasetupResult * this_object = CA_CENTER_CASETUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_center_casetup_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCenterCasetupResult * this_object = CA_CENTER_CASETUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CenterCasetupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_center_casetup_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  caCenterCasetupResult *self = CA_CENTER_CASETUP_RESULT (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CASETUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_center_casetup_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  caCenterCasetupResult *self = CA_CENTER_CASETUP_RESULT (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CASETUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_center_casetup_result_instance_init (caCenterCasetupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (CA_TYPE_C_A_PARAMTER, NULL);
  object->__isset_success = FALSE;
}

static void 
ca_center_casetup_result_finalize (GObject *object)
{
  caCenterCasetupResult *tobject = CA_CENTER_CASETUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
ca_center_casetup_result_class_init (caCenterCasetupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_center_casetup_result_read;
  struct_class->write = ca_center_casetup_result_write;

  gobject_class->finalize = ca_center_casetup_result_finalize;
  gobject_class->get_property = ca_center_casetup_result_get_property;
  gobject_class->set_property = ca_center_casetup_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CASETUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         CA_TYPE_C_A_PARAMTER,
                         G_PARAM_READWRITE));
}

GType
ca_center_casetup_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCenterCasetupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_center_casetup_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCenterCasetupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_center_casetup_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCenterCasetupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _caCenterUserRegisterArgsProperties
{
  PROP_CA_CENTER_USER_REGISTER_ARGS_0,
  PROP_CA_CENTER_USER_REGISTER_ARGS_PUB,
  PROP_CA_CENTER_USER_REGISTER_ARGS_UID,
  PROP_CA_CENTER_USER_REGISTER_ARGS_ATTRIBUTES
};

/* reads a center_user_register_args object */
static gint32
ca_center_user_register_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCenterUserRegisterArgs * this_object = CA_CENTER_USER_REGISTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->uid != NULL)
          {
            g_free(this_object->uid);
            this_object->uid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->uid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_uid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem8 = NULL;
              if (_elem8 != NULL)
              {
                g_free(_elem8);
                _elem8 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem8, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_center_user_register_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCenterUserRegisterArgs * this_object = CA_CENTER_USER_REGISTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CenterUserRegisterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uid", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->uid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i9;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i9 = 0; i9 < (this_object->attributes ? this_object->attributes->len : 0); i9++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i9)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_center_user_register_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  caCenterUserRegisterArgs *self = CA_CENTER_USER_REGISTER_ARGS (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_USER_REGISTER_ARGS_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_CA_CENTER_USER_REGISTER_ARGS_UID:
      if (self->uid != NULL)
        g_free (self->uid);
      self->uid = g_value_dup_string (value);
      self->__isset_uid = TRUE;
      break;

    case PROP_CA_CENTER_USER_REGISTER_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_center_user_register_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  caCenterUserRegisterArgs *self = CA_CENTER_USER_REGISTER_ARGS (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_USER_REGISTER_ARGS_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_CA_CENTER_USER_REGISTER_ARGS_UID:
      g_value_set_string (value, self->uid);
      break;

    case PROP_CA_CENTER_USER_REGISTER_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_center_user_register_args_instance_init (caCenterUserRegisterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->uid = NULL;
  object->__isset_uid = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
}

static void 
ca_center_user_register_args_finalize (GObject *object)
{
  caCenterUserRegisterArgs *tobject = CA_CENTER_USER_REGISTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->uid != NULL)
  {
    g_free(tobject->uid);
    tobject->uid = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
ca_center_user_register_args_class_init (caCenterUserRegisterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_center_user_register_args_read;
  struct_class->write = ca_center_user_register_args_write;

  gobject_class->finalize = ca_center_user_register_args_finalize;
  gobject_class->get_property = ca_center_user_register_args_get_property;
  gobject_class->set_property = ca_center_user_register_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_USER_REGISTER_ARGS_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_USER_REGISTER_ARGS_UID,
     g_param_spec_string ("uid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_USER_REGISTER_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
ca_center_user_register_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCenterUserRegisterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_center_user_register_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCenterUserRegisterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_center_user_register_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCenterUserRegisterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _caCenterUserRegisterResultProperties
{
  PROP_CA_CENTER_USER_REGISTER_RESULT_0,
  PROP_CA_CENTER_USER_REGISTER_RESULT_SUCCESS
};

/* reads a center_user_register_result object */
static gint32
ca_center_user_register_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCenterUserRegisterResult * this_object = CA_CENTER_USER_REGISTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_center_user_register_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCenterUserRegisterResult * this_object = CA_CENTER_USER_REGISTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CenterUserRegisterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_center_user_register_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  caCenterUserRegisterResult *self = CA_CENTER_USER_REGISTER_RESULT (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_USER_REGISTER_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_center_user_register_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  caCenterUserRegisterResult *self = CA_CENTER_USER_REGISTER_RESULT (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_USER_REGISTER_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_center_user_register_result_instance_init (caCenterUserRegisterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (CA_TYPE_USER_REGISTER, NULL);
  object->__isset_success = FALSE;
}

static void 
ca_center_user_register_result_finalize (GObject *object)
{
  caCenterUserRegisterResult *tobject = CA_CENTER_USER_REGISTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
ca_center_user_register_result_class_init (caCenterUserRegisterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_center_user_register_result_read;
  struct_class->write = ca_center_user_register_result_write;

  gobject_class->finalize = ca_center_user_register_result_finalize;
  gobject_class->get_property = ca_center_user_register_result_get_property;
  gobject_class->set_property = ca_center_user_register_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_USER_REGISTER_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         CA_TYPE_USER_REGISTER,
                         G_PARAM_READWRITE));
}

GType
ca_center_user_register_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCenterUserRegisterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_center_user_register_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCenterUserRegisterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_center_user_register_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCenterUserRegisterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _caCenterCakeygenArgsProperties
{
  PROP_CA_CENTER_CAKEYGEN_ARGS_0,
  PROP_CA_CENTER_CAKEYGEN_ARGS_PARAM,
  PROP_CA_CENTER_CAKEYGEN_ARGS_ATTRIBUTES,
  PROP_CA_CENTER_CAKEYGEN_ARGS_UID
};

/* reads a center_cakeygen_args object */
static gint32
ca_center_cakeygen_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCenterCakeygenArgs * this_object = CA_CENTER_CAKEYGEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->param), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_param = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem10 = NULL;
              if (_elem10 != NULL)
              {
                g_free(_elem10);
                _elem10 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem10, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->uid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_uid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_center_cakeygen_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCenterCakeygenArgs * this_object = CA_CENTER_CAKEYGEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CenterCakeygenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "param", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->param), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i11;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i11 = 0; i11 < (this_object->attributes ? this_object->attributes->len : 0); i11++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i11)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uid", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->uid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_center_cakeygen_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  caCenterCakeygenArgs *self = CA_CENTER_CAKEYGEN_ARGS (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CAKEYGEN_ARGS_PARAM:
      if (self->param != NULL)
        g_object_unref (self->param);
      self->param = g_value_dup_object (value);
      self->__isset_param = TRUE;
      break;

    case PROP_CA_CENTER_CAKEYGEN_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_CA_CENTER_CAKEYGEN_ARGS_UID:
      self->uid = g_value_get_int (value);
      self->__isset_uid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_center_cakeygen_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  caCenterCakeygenArgs *self = CA_CENTER_CAKEYGEN_ARGS (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CAKEYGEN_ARGS_PARAM:
      g_value_set_object (value, self->param);
      break;

    case PROP_CA_CENTER_CAKEYGEN_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_CA_CENTER_CAKEYGEN_ARGS_UID:
      g_value_set_int (value, self->uid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_center_cakeygen_args_instance_init (caCenterCakeygenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->param = g_object_new (CA_TYPE_C_A_PARAMTER, NULL);
  object->__isset_param = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
  object->uid = 0;
  object->__isset_uid = FALSE;
}

static void 
ca_center_cakeygen_args_finalize (GObject *object)
{
  caCenterCakeygenArgs *tobject = CA_CENTER_CAKEYGEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->param != NULL)
  {
    g_object_unref(tobject->param);
    tobject->param = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
ca_center_cakeygen_args_class_init (caCenterCakeygenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_center_cakeygen_args_read;
  struct_class->write = ca_center_cakeygen_args_write;

  gobject_class->finalize = ca_center_cakeygen_args_finalize;
  gobject_class->get_property = ca_center_cakeygen_args_get_property;
  gobject_class->set_property = ca_center_cakeygen_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CAKEYGEN_ARGS_PARAM,
     g_param_spec_object ("param",
                         NULL,
                         NULL,
                         CA_TYPE_C_A_PARAMTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CAKEYGEN_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CAKEYGEN_ARGS_UID,
     g_param_spec_int ("uid",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
ca_center_cakeygen_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCenterCakeygenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_center_cakeygen_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCenterCakeygenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_center_cakeygen_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCenterCakeygenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _caCenterCakeygenResultProperties
{
  PROP_CA_CENTER_CAKEYGEN_RESULT_0,
  PROP_CA_CENTER_CAKEYGEN_RESULT_SUCCESS
};

/* reads a center_cakeygen_result object */
static gint32
ca_center_cakeygen_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  caCenterCakeygenResult * this_object = CA_CENTER_CAKEYGEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
ca_center_cakeygen_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  caCenterCakeygenResult * this_object = CA_CENTER_CAKEYGEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CenterCakeygenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
ca_center_cakeygen_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  caCenterCakeygenResult *self = CA_CENTER_CAKEYGEN_RESULT (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CAKEYGEN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
ca_center_cakeygen_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  caCenterCakeygenResult *self = CA_CENTER_CAKEYGEN_RESULT (object);

  switch (property_id)
  {
    case PROP_CA_CENTER_CAKEYGEN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
ca_center_cakeygen_result_instance_init (caCenterCakeygenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (CA_TYPE_U_REVO_KEY, NULL);
  object->__isset_success = FALSE;
}

static void 
ca_center_cakeygen_result_finalize (GObject *object)
{
  caCenterCakeygenResult *tobject = CA_CENTER_CAKEYGEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
ca_center_cakeygen_result_class_init (caCenterCakeygenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = ca_center_cakeygen_result_read;
  struct_class->write = ca_center_cakeygen_result_write;

  gobject_class->finalize = ca_center_cakeygen_result_finalize;
  gobject_class->get_property = ca_center_cakeygen_result_get_property;
  gobject_class->set_property = ca_center_cakeygen_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CA_CENTER_CAKEYGEN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         CA_TYPE_U_REVO_KEY,
                         G_PARAM_READWRITE));
}

GType
ca_center_cakeygen_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (caCenterCakeygenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) ca_center_cakeygen_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (caCenterCakeygenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) ca_center_cakeygen_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "caCenterCakeygenResultType",
                                   &type_info, 0);
  }

  return type;
}

