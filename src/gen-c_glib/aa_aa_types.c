/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "aa_aa_types.h"
#include <thrift/c_glib/thrift.h>

enum _aaAuthParamterProperties
{
  PROP_AA_AUTH_PARAMTER_0,
  PROP_AA_AUTH_PARAMTER_AID,
  PROP_AA_AUTH_PARAMTER_AUTH_PK,
  PROP_AA_AUTH_PARAMTER_AUTH_MSK,
  PROP_AA_AUTH_PARAMTER_ATTR_PKS,
  PROP_AA_AUTH_PARAMTER_ATTR_MSKS,
  PROP_AA_AUTH_PARAMTER_ATTRIBUTES
};

/* reads a auth_paramter object */
static gint32
aa_auth_paramter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthParamter * this_object = AA_AUTH_PARAMTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aid != NULL)
          {
            g_free(this_object->aid);
            this_object->aid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->aid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_aid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->auth_pk != NULL)
          {
            g_free(this_object->auth_pk);
            this_object->auth_pk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->auth_pk = g_byte_array_new();
          g_byte_array_append (this_object->auth_pk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_auth_pk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->auth_msk != NULL)
          {
            g_free(this_object->auth_msk);
            this_object->auth_msk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->auth_msk = g_byte_array_new();
          g_byte_array_append (this_object->auth_msk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_auth_msk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key0 = NULL;
              GByteArray * val1 = NULL;
              if (key0 != NULL)
              {
                g_free(key0);
                key0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key0, error)) < 0)
                return -1;
              xfer += ret;
              if (val1 != NULL)
              {
                g_free(val1);
                val1 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val1 = g_byte_array_new();
              g_byte_array_append (val1, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attr_pks && key0)
                g_hash_table_insert ((GHashTable *)this_object->attr_pks, (gpointer) key0, (gpointer) val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attr_pks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key2 = NULL;
              GByteArray * val3 = NULL;
              if (key2 != NULL)
              {
                g_free(key2);
                key2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key2, error)) < 0)
                return -1;
              xfer += ret;
              if (val3 != NULL)
              {
                g_free(val3);
                val3 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val3 = g_byte_array_new();
              g_byte_array_append (val3, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attr_msks && key2)
                g_hash_table_insert ((GHashTable *)this_object->attr_msks, (gpointer) key2, (gpointer) val3);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attr_msks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem4 = NULL;
              if (_elem4 != NULL)
              {
                g_free(_elem4);
                _elem4 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem4, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_auth_paramter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthParamter * this_object = AA_AUTH_PARAMTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthParamter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aid", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->aid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth_pk", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->auth_pk ? ((GByteArray *) this_object->auth_pk)->data : NULL, this_object->auth_pk ? ((GByteArray *) this_object->auth_pk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth_msk", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->auth_msk ? ((GByteArray *) this_object->auth_msk)->data : NULL, this_object->auth_msk ? ((GByteArray *) this_object->auth_msk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_pks", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key5 = NULL;
    GByteArray * val6 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attr_pks ? (gint32) g_hash_table_size ((GHashTable *) this_object->attr_pks) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attr_pks)
      g_hash_table_foreach ((GHashTable *) this_object->attr_pks, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key5 = keys[i];
      val6 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attr_pks), (gpointer) key5);

      if ((ret = thrift_protocol_write_string (protocol,  key5, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val6 ? ((GByteArray *)  val6)->data : NULL,  val6 ? ((GByteArray *)  val6)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_msks", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key7 = NULL;
    GByteArray * val8 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attr_msks ? (gint32) g_hash_table_size ((GHashTable *) this_object->attr_msks) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attr_msks)
      g_hash_table_foreach ((GHashTable *) this_object->attr_msks, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key7 = keys[i];
      val8 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attr_msks), (gpointer) key7);

      if ((ret = thrift_protocol_write_string (protocol,  key7, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val8 ? ((GByteArray *)  val8)->data : NULL,  val8 ? ((GByteArray *)  val8)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i9;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i9 = 0; i9 < (this_object->attributes ? this_object->attributes->len : 0); i9++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i9)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_auth_paramter_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  aaAuthParamter *self = AA_AUTH_PARAMTER (object);

  switch (property_id)
  {
    case PROP_AA_AUTH_PARAMTER_AID:
      if (self->aid != NULL)
        g_free (self->aid);
      self->aid = g_value_dup_string (value);
      self->__isset_aid = TRUE;
      break;

    case PROP_AA_AUTH_PARAMTER_AUTH_PK:
      if (self->auth_pk != NULL)
        g_byte_array_unref (self->auth_pk);
      self->auth_pk = g_value_dup_boxed (value);
      self->__isset_auth_pk = TRUE;
      break;

    case PROP_AA_AUTH_PARAMTER_AUTH_MSK:
      if (self->auth_msk != NULL)
        g_byte_array_unref (self->auth_msk);
      self->auth_msk = g_value_dup_boxed (value);
      self->__isset_auth_msk = TRUE;
      break;

    case PROP_AA_AUTH_PARAMTER_ATTR_PKS:
      if (self->attr_pks != NULL)
        g_hash_table_unref (self->attr_pks);
      self->attr_pks = g_value_dup_boxed (value);
      self->__isset_attr_pks = TRUE;
      break;

    case PROP_AA_AUTH_PARAMTER_ATTR_MSKS:
      if (self->attr_msks != NULL)
        g_hash_table_unref (self->attr_msks);
      self->attr_msks = g_value_dup_boxed (value);
      self->__isset_attr_msks = TRUE;
      break;

    case PROP_AA_AUTH_PARAMTER_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_auth_paramter_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  aaAuthParamter *self = AA_AUTH_PARAMTER (object);

  switch (property_id)
  {
    case PROP_AA_AUTH_PARAMTER_AID:
      g_value_set_string (value, self->aid);
      break;

    case PROP_AA_AUTH_PARAMTER_AUTH_PK:
      g_value_set_boxed (value, self->auth_pk);
      break;

    case PROP_AA_AUTH_PARAMTER_AUTH_MSK:
      g_value_set_boxed (value, self->auth_msk);
      break;

    case PROP_AA_AUTH_PARAMTER_ATTR_PKS:
      g_value_set_boxed (value, self->attr_pks);
      break;

    case PROP_AA_AUTH_PARAMTER_ATTR_MSKS:
      g_value_set_boxed (value, self->attr_msks);
      break;

    case PROP_AA_AUTH_PARAMTER_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_auth_paramter_instance_init (aaAuthParamter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aid = NULL;
  object->__isset_aid = FALSE;
  object->auth_pk = NULL;
  object->__isset_auth_pk = FALSE;
  object->auth_msk = NULL;
  object->__isset_auth_msk = FALSE;
  object->attr_pks = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_attr_pks = FALSE;
  object->attr_msks = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_attr_msks = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
}

static void 
aa_auth_paramter_finalize (GObject *object)
{
  aaAuthParamter *tobject = AA_AUTH_PARAMTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aid != NULL)
  {
    g_free(tobject->aid);
    tobject->aid = NULL;
  }
  if (tobject->auth_pk != NULL)
  {
    thrift_string_free(tobject->auth_pk);
    tobject->auth_pk = NULL;
  }
  if (tobject->auth_msk != NULL)
  {
    thrift_string_free(tobject->auth_msk);
    tobject->auth_msk = NULL;
  }
  if (tobject->attr_pks != NULL)
  {
    g_hash_table_destroy (tobject->attr_pks);
    tobject->attr_pks = NULL;
  }
  if (tobject->attr_msks != NULL)
  {
    g_hash_table_destroy (tobject->attr_msks);
    tobject->attr_msks = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
aa_auth_paramter_class_init (aaAuthParamterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_auth_paramter_read;
  struct_class->write = aa_auth_paramter_write;

  gobject_class->finalize = aa_auth_paramter_finalize;
  gobject_class->get_property = aa_auth_paramter_get_property;
  gobject_class->set_property = aa_auth_paramter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTH_PARAMTER_AID,
     g_param_spec_string ("aid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTH_PARAMTER_AUTH_PK,
     g_param_spec_boxed ("auth_pk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTH_PARAMTER_AUTH_MSK,
     g_param_spec_boxed ("auth_msk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTH_PARAMTER_ATTR_PKS,
     g_param_spec_boxed ("attr_pks",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTH_PARAMTER_ATTR_MSKS,
     g_param_spec_boxed ("attr_msks",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTH_PARAMTER_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
aa_auth_paramter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthParamterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_auth_paramter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthParamter),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_auth_paramter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthParamterType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaARevoKeyProperties
{
  PROP_AA_A_REVO_KEY_0,
  PROP_AA_A_REVO_KEY_AID,
  PROP_AA_A_REVO_KEY_K,
  PROP_AA_A_REVO_KEY_L,
  PROP_AA_A_REVO_KEY_R,
  PROP_AA_A_REVO_KEY_KX,
  PROP_AA_A_REVO_KEY_ATTRIBUTES
};

/* reads a a_revo_key object */
static gint32
aa_a_revo_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaARevoKey * this_object = AA_A_REVO_KEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aid != NULL)
          {
            g_free(this_object->aid);
            this_object->aid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->aid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_aid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->K != NULL)
          {
            g_free(this_object->K);
            this_object->K = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->K = g_byte_array_new();
          g_byte_array_append (this_object->K, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_K = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->L != NULL)
          {
            g_free(this_object->L);
            this_object->L = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->L = g_byte_array_new();
          g_byte_array_append (this_object->L, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_L = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->R != NULL)
          {
            g_free(this_object->R);
            this_object->R = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->R = g_byte_array_new();
          g_byte_array_append (this_object->R, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_R = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key10 = NULL;
              GByteArray * val11 = NULL;
              if (key10 != NULL)
              {
                g_free(key10);
                key10 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key10, error)) < 0)
                return -1;
              xfer += ret;
              if (val11 != NULL)
              {
                g_free(val11);
                val11 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val11 = g_byte_array_new();
              g_byte_array_append (val11, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->kx && key10)
                g_hash_table_insert ((GHashTable *)this_object->kx, (gpointer) key10, (gpointer) val11);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_kx = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem12 = NULL;
              if (_elem12 != NULL)
              {
                g_free(_elem12);
                _elem12 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem12, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_a_revo_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaARevoKey * this_object = AA_A_REVO_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ARevoKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aid", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->aid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "K", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->K ? ((GByteArray *) this_object->K)->data : NULL, this_object->K ? ((GByteArray *) this_object->K)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "L", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->L ? ((GByteArray *) this_object->L)->data : NULL, this_object->L ? ((GByteArray *) this_object->L)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "R", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->R ? ((GByteArray *) this_object->R)->data : NULL, this_object->R ? ((GByteArray *) this_object->R)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "kx", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key13 = NULL;
    GByteArray * val14 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->kx ? (gint32) g_hash_table_size ((GHashTable *) this_object->kx) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->kx)
      g_hash_table_foreach ((GHashTable *) this_object->kx, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key13 = keys[i];
      val14 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->kx), (gpointer) key13);

      if ((ret = thrift_protocol_write_string (protocol,  key13, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val14 ? ((GByteArray *)  val14)->data : NULL,  val14 ? ((GByteArray *)  val14)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < (this_object->attributes ? this_object->attributes->len : 0); i15++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i15)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_a_revo_key_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  aaARevoKey *self = AA_A_REVO_KEY (object);

  switch (property_id)
  {
    case PROP_AA_A_REVO_KEY_AID:
      if (self->aid != NULL)
        g_free (self->aid);
      self->aid = g_value_dup_string (value);
      self->__isset_aid = TRUE;
      break;

    case PROP_AA_A_REVO_KEY_K:
      if (self->K != NULL)
        g_byte_array_unref (self->K);
      self->K = g_value_dup_boxed (value);
      self->__isset_K = TRUE;
      break;

    case PROP_AA_A_REVO_KEY_L:
      if (self->L != NULL)
        g_byte_array_unref (self->L);
      self->L = g_value_dup_boxed (value);
      self->__isset_L = TRUE;
      break;

    case PROP_AA_A_REVO_KEY_R:
      if (self->R != NULL)
        g_byte_array_unref (self->R);
      self->R = g_value_dup_boxed (value);
      self->__isset_R = TRUE;
      break;

    case PROP_AA_A_REVO_KEY_KX:
      if (self->kx != NULL)
        g_hash_table_unref (self->kx);
      self->kx = g_value_dup_boxed (value);
      self->__isset_kx = TRUE;
      break;

    case PROP_AA_A_REVO_KEY_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_a_revo_key_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  aaARevoKey *self = AA_A_REVO_KEY (object);

  switch (property_id)
  {
    case PROP_AA_A_REVO_KEY_AID:
      g_value_set_string (value, self->aid);
      break;

    case PROP_AA_A_REVO_KEY_K:
      g_value_set_boxed (value, self->K);
      break;

    case PROP_AA_A_REVO_KEY_L:
      g_value_set_boxed (value, self->L);
      break;

    case PROP_AA_A_REVO_KEY_R:
      g_value_set_boxed (value, self->R);
      break;

    case PROP_AA_A_REVO_KEY_KX:
      g_value_set_boxed (value, self->kx);
      break;

    case PROP_AA_A_REVO_KEY_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_a_revo_key_instance_init (aaARevoKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aid = NULL;
  object->__isset_aid = FALSE;
  object->K = NULL;
  object->__isset_K = FALSE;
  object->L = NULL;
  object->__isset_L = FALSE;
  object->R = NULL;
  object->__isset_R = FALSE;
  object->kx = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_kx = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
}

static void 
aa_a_revo_key_finalize (GObject *object)
{
  aaARevoKey *tobject = AA_A_REVO_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aid != NULL)
  {
    g_free(tobject->aid);
    tobject->aid = NULL;
  }
  if (tobject->K != NULL)
  {
    thrift_string_free(tobject->K);
    tobject->K = NULL;
  }
  if (tobject->L != NULL)
  {
    thrift_string_free(tobject->L);
    tobject->L = NULL;
  }
  if (tobject->R != NULL)
  {
    thrift_string_free(tobject->R);
    tobject->R = NULL;
  }
  if (tobject->kx != NULL)
  {
    g_hash_table_destroy (tobject->kx);
    tobject->kx = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
aa_a_revo_key_class_init (aaARevoKeyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_a_revo_key_read;
  struct_class->write = aa_a_revo_key_write;

  gobject_class->finalize = aa_a_revo_key_finalize;
  gobject_class->get_property = aa_a_revo_key_get_property;
  gobject_class->set_property = aa_a_revo_key_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_A_REVO_KEY_AID,
     g_param_spec_string ("aid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_A_REVO_KEY_K,
     g_param_spec_boxed ("K",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_A_REVO_KEY_L,
     g_param_spec_boxed ("L",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_A_REVO_KEY_R,
     g_param_spec_boxed ("R",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_A_REVO_KEY_KX,
     g_param_spec_boxed ("kx",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_A_REVO_KEY_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
aa_a_revo_key_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaARevoKeyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_a_revo_key_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaARevoKey),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_a_revo_key_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaARevoKeyType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaAttrPairProperties
{
  PROP_AA_ATTR_PAIR_0,
  PROP_AA_ATTR_PAIR_ATTR_PK,
  PROP_AA_ATTR_PAIR_ATTR_MSK
};

/* reads a attr_pair object */
static gint32
aa_attr_pair_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAttrPair * this_object = AA_ATTR_PAIR(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->attr_pk != NULL)
          {
            g_free(this_object->attr_pk);
            this_object->attr_pk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->attr_pk = g_byte_array_new();
          g_byte_array_append (this_object->attr_pk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_attr_pk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->attr_msk != NULL)
          {
            g_free(this_object->attr_msk);
            this_object->attr_msk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->attr_msk = g_byte_array_new();
          g_byte_array_append (this_object->attr_msk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_attr_msk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_attr_pair_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAttrPair * this_object = AA_ATTR_PAIR(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AttrPair", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_pk", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->attr_pk ? ((GByteArray *) this_object->attr_pk)->data : NULL, this_object->attr_pk ? ((GByteArray *) this_object->attr_pk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_msk", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->attr_msk ? ((GByteArray *) this_object->attr_msk)->data : NULL, this_object->attr_msk ? ((GByteArray *) this_object->attr_msk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_attr_pair_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  aaAttrPair *self = AA_ATTR_PAIR (object);

  switch (property_id)
  {
    case PROP_AA_ATTR_PAIR_ATTR_PK:
      if (self->attr_pk != NULL)
        g_byte_array_unref (self->attr_pk);
      self->attr_pk = g_value_dup_boxed (value);
      self->__isset_attr_pk = TRUE;
      break;

    case PROP_AA_ATTR_PAIR_ATTR_MSK:
      if (self->attr_msk != NULL)
        g_byte_array_unref (self->attr_msk);
      self->attr_msk = g_value_dup_boxed (value);
      self->__isset_attr_msk = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_attr_pair_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  aaAttrPair *self = AA_ATTR_PAIR (object);

  switch (property_id)
  {
    case PROP_AA_ATTR_PAIR_ATTR_PK:
      g_value_set_boxed (value, self->attr_pk);
      break;

    case PROP_AA_ATTR_PAIR_ATTR_MSK:
      g_value_set_boxed (value, self->attr_msk);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_attr_pair_instance_init (aaAttrPair * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->attr_pk = NULL;
  object->__isset_attr_pk = FALSE;
  object->attr_msk = NULL;
  object->__isset_attr_msk = FALSE;
}

static void 
aa_attr_pair_finalize (GObject *object)
{
  aaAttrPair *tobject = AA_ATTR_PAIR (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->attr_pk != NULL)
  {
    thrift_string_free(tobject->attr_pk);
    tobject->attr_pk = NULL;
  }
  if (tobject->attr_msk != NULL)
  {
    thrift_string_free(tobject->attr_msk);
    tobject->attr_msk = NULL;
  }
}

static void
aa_attr_pair_class_init (aaAttrPairClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_attr_pair_read;
  struct_class->write = aa_attr_pair_write;

  gobject_class->finalize = aa_attr_pair_finalize;
  gobject_class->get_property = aa_attr_pair_get_property;
  gobject_class->set_property = aa_attr_pair_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_ATTR_PAIR_ATTR_PK,
     g_param_spec_boxed ("attr_pk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_ATTR_PAIR_ATTR_MSK,
     g_param_spec_boxed ("attr_msk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
aa_attr_pair_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAttrPairClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_attr_pair_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAttrPair),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_attr_pair_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAttrPairType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _aaAuthorityAasetupArgsProperties
{
  PROP_AA_AUTHORITY_AASETUP_ARGS_0,
  PROP_AA_AUTHORITY_AASETUP_ARGS_PUB,
  PROP_AA_AUTHORITY_AASETUP_ARGS_ATTRIBUTES,
  PROP_AA_AUTHORITY_AASETUP_ARGS_AID
};

/* reads a authority_aasetup_args object */
static gint32
aa_authority_aasetup_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthorityAasetupArgs * this_object = AA_AUTHORITY_AASETUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem16 = NULL;
              if (_elem16 != NULL)
              {
                g_free(_elem16);
                _elem16 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem16, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem16);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->aid != NULL)
          {
            g_free(this_object->aid);
            this_object->aid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->aid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_aid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_authority_aasetup_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthorityAasetupArgs * this_object = AA_AUTHORITY_AASETUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorityAasetupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i17;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i17 = 0; i17 < (this_object->attributes ? this_object->attributes->len : 0); i17++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i17)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aid", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->aid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_authority_aasetup_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  aaAuthorityAasetupArgs *self = AA_AUTHORITY_AASETUP_ARGS (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AASETUP_ARGS_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_AA_AUTHORITY_AASETUP_ARGS_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    case PROP_AA_AUTHORITY_AASETUP_ARGS_AID:
      if (self->aid != NULL)
        g_free (self->aid);
      self->aid = g_value_dup_string (value);
      self->__isset_aid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_authority_aasetup_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  aaAuthorityAasetupArgs *self = AA_AUTHORITY_AASETUP_ARGS (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AASETUP_ARGS_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_AA_AUTHORITY_AASETUP_ARGS_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    case PROP_AA_AUTHORITY_AASETUP_ARGS_AID:
      g_value_set_string (value, self->aid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_authority_aasetup_args_instance_init (aaAuthorityAasetupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
  object->aid = NULL;
  object->__isset_aid = FALSE;
}

static void 
aa_authority_aasetup_args_finalize (GObject *object)
{
  aaAuthorityAasetupArgs *tobject = AA_AUTHORITY_AASETUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
  if (tobject->aid != NULL)
  {
    g_free(tobject->aid);
    tobject->aid = NULL;
  }
}

static void
aa_authority_aasetup_args_class_init (aaAuthorityAasetupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_authority_aasetup_args_read;
  struct_class->write = aa_authority_aasetup_args_write;

  gobject_class->finalize = aa_authority_aasetup_args_finalize;
  gobject_class->get_property = aa_authority_aasetup_args_get_property;
  gobject_class->set_property = aa_authority_aasetup_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AASETUP_ARGS_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AASETUP_ARGS_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AASETUP_ARGS_AID,
     g_param_spec_string ("aid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
aa_authority_aasetup_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthorityAasetupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_authority_aasetup_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthorityAasetupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_authority_aasetup_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthorityAasetupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaAuthorityAasetupResultProperties
{
  PROP_AA_AUTHORITY_AASETUP_RESULT_0,
  PROP_AA_AUTHORITY_AASETUP_RESULT_SUCCESS
};

/* reads a authority_aasetup_result object */
static gint32
aa_authority_aasetup_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthorityAasetupResult * this_object = AA_AUTHORITY_AASETUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_authority_aasetup_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthorityAasetupResult * this_object = AA_AUTHORITY_AASETUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorityAasetupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_authority_aasetup_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  aaAuthorityAasetupResult *self = AA_AUTHORITY_AASETUP_RESULT (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AASETUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_authority_aasetup_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  aaAuthorityAasetupResult *self = AA_AUTHORITY_AASETUP_RESULT (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AASETUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_authority_aasetup_result_instance_init (aaAuthorityAasetupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (AA_TYPE_AUTH_PARAMTER, NULL);
  object->__isset_success = FALSE;
}

static void 
aa_authority_aasetup_result_finalize (GObject *object)
{
  aaAuthorityAasetupResult *tobject = AA_AUTHORITY_AASETUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
aa_authority_aasetup_result_class_init (aaAuthorityAasetupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_authority_aasetup_result_read;
  struct_class->write = aa_authority_aasetup_result_write;

  gobject_class->finalize = aa_authority_aasetup_result_finalize;
  gobject_class->get_property = aa_authority_aasetup_result_get_property;
  gobject_class->set_property = aa_authority_aasetup_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AASETUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         AA_TYPE_AUTH_PARAMTER,
                         G_PARAM_READWRITE));
}

GType
aa_authority_aasetup_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthorityAasetupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_authority_aasetup_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthorityAasetupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_authority_aasetup_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthorityAasetupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaAuthorityAakeygenArgsProperties
{
  PROP_AA_AUTHORITY_AAKEYGEN_ARGS_0,
  PROP_AA_AUTHORITY_AAKEYGEN_ARGS_AUTH,
  PROP_AA_AUTHORITY_AAKEYGEN_ARGS_PUB,
  PROP_AA_AUTHORITY_AAKEYGEN_ARGS_CERT,
  PROP_AA_AUTHORITY_AAKEYGEN_ARGS_ATTRIBTUES
};

/* reads a authority_aakeygen_args object */
static gint32
aa_authority_aakeygen_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthorityAakeygenArgs * this_object = AA_AUTHORITY_AAKEYGEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_auth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->cert != NULL)
          {
            g_free(this_object->cert);
            this_object->cert = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->cert = g_byte_array_new();
          g_byte_array_append (this_object->cert, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_cert = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem18 = NULL;
              if (_elem18 != NULL)
              {
                g_free(_elem18);
                _elem18 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem18, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attribtues, _elem18);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attribtues = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_authority_aakeygen_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthorityAakeygenArgs * this_object = AA_AUTHORITY_AAKEYGEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorityAakeygenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->auth), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cert", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->cert ? ((GByteArray *) this_object->cert)->data : NULL, this_object->cert ? ((GByteArray *) this_object->cert)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attribtues", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i19;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attribtues ? this_object->attribtues->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i19 = 0; i19 < (this_object->attribtues ? this_object->attribtues->len : 0); i19++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attribtues, i19)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_authority_aakeygen_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  aaAuthorityAakeygenArgs *self = AA_AUTHORITY_AAKEYGEN_ARGS (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_AUTH:
      if (self->auth != NULL)
        g_object_unref (self->auth);
      self->auth = g_value_dup_object (value);
      self->__isset_auth = TRUE;
      break;

    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_CERT:
      if (self->cert != NULL)
        g_byte_array_unref (self->cert);
      self->cert = g_value_dup_boxed (value);
      self->__isset_cert = TRUE;
      break;

    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_ATTRIBTUES:
      if (self->attribtues != NULL)
        g_ptr_array_unref (self->attribtues);
      self->attribtues = g_value_dup_boxed (value);
      self->__isset_attribtues = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_authority_aakeygen_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  aaAuthorityAakeygenArgs *self = AA_AUTHORITY_AAKEYGEN_ARGS (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_AUTH:
      g_value_set_object (value, self->auth);
      break;

    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_CERT:
      g_value_set_boxed (value, self->cert);
      break;

    case PROP_AA_AUTHORITY_AAKEYGEN_ARGS_ATTRIBTUES:
      g_value_set_boxed (value, self->attribtues);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_authority_aakeygen_args_instance_init (aaAuthorityAakeygenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->auth = g_object_new (AA_TYPE_AUTH_PARAMTER, NULL);
  object->__isset_auth = FALSE;
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->cert = NULL;
  object->__isset_cert = FALSE;
  object->attribtues = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attribtues = FALSE;
}

static void 
aa_authority_aakeygen_args_finalize (GObject *object)
{
  aaAuthorityAakeygenArgs *tobject = AA_AUTHORITY_AAKEYGEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->auth != NULL)
  {
    g_object_unref(tobject->auth);
    tobject->auth = NULL;
  }
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->cert != NULL)
  {
    thrift_string_free(tobject->cert);
    tobject->cert = NULL;
  }
  if (tobject->attribtues != NULL)
  {
    g_ptr_array_unref (tobject->attribtues);
    tobject->attribtues = NULL;
  }
}

static void
aa_authority_aakeygen_args_class_init (aaAuthorityAakeygenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_authority_aakeygen_args_read;
  struct_class->write = aa_authority_aakeygen_args_write;

  gobject_class->finalize = aa_authority_aakeygen_args_finalize;
  gobject_class->get_property = aa_authority_aakeygen_args_get_property;
  gobject_class->set_property = aa_authority_aakeygen_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AAKEYGEN_ARGS_AUTH,
     g_param_spec_object ("auth",
                         NULL,
                         NULL,
                         AA_TYPE_AUTH_PARAMTER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AAKEYGEN_ARGS_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AAKEYGEN_ARGS_CERT,
     g_param_spec_boxed ("cert",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AAKEYGEN_ARGS_ATTRIBTUES,
     g_param_spec_boxed ("attribtues",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
aa_authority_aakeygen_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthorityAakeygenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_authority_aakeygen_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthorityAakeygenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_authority_aakeygen_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthorityAakeygenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaAuthorityAakeygenResultProperties
{
  PROP_AA_AUTHORITY_AAKEYGEN_RESULT_0,
  PROP_AA_AUTHORITY_AAKEYGEN_RESULT_SUCCESS
};

/* reads a authority_aakeygen_result object */
static gint32
aa_authority_aakeygen_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthorityAakeygenResult * this_object = AA_AUTHORITY_AAKEYGEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_authority_aakeygen_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthorityAakeygenResult * this_object = AA_AUTHORITY_AAKEYGEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorityAakeygenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_authority_aakeygen_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  aaAuthorityAakeygenResult *self = AA_AUTHORITY_AAKEYGEN_RESULT (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AAKEYGEN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_authority_aakeygen_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  aaAuthorityAakeygenResult *self = AA_AUTHORITY_AAKEYGEN_RESULT (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_AAKEYGEN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_authority_aakeygen_result_instance_init (aaAuthorityAakeygenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (AA_TYPE_A_REVO_KEY, NULL);
  object->__isset_success = FALSE;
}

static void 
aa_authority_aakeygen_result_finalize (GObject *object)
{
  aaAuthorityAakeygenResult *tobject = AA_AUTHORITY_AAKEYGEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
aa_authority_aakeygen_result_class_init (aaAuthorityAakeygenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_authority_aakeygen_result_read;
  struct_class->write = aa_authority_aakeygen_result_write;

  gobject_class->finalize = aa_authority_aakeygen_result_finalize;
  gobject_class->get_property = aa_authority_aakeygen_result_get_property;
  gobject_class->set_property = aa_authority_aakeygen_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_AAKEYGEN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         AA_TYPE_A_REVO_KEY,
                         G_PARAM_READWRITE));
}

GType
aa_authority_aakeygen_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthorityAakeygenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_authority_aakeygen_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthorityAakeygenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_authority_aakeygen_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthorityAakeygenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaAuthorityUpdatekeyArgsProperties
{
  PROP_AA_AUTHORITY_UPDATEKEY_ARGS_0,
  PROP_AA_AUTHORITY_UPDATEKEY_ARGS_AUTH_MSK,
  PROP_AA_AUTHORITY_UPDATEKEY_ARGS_PUB,
  PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_PK,
  PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_MSK,
  PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTRIBUTE
};

/* reads a authority_updatekey_args object */
static gint32
aa_authority_updatekey_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthorityUpdatekeyArgs * this_object = AA_AUTHORITY_UPDATEKEY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->auth_msk != NULL)
          {
            g_free(this_object->auth_msk);
            this_object->auth_msk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->auth_msk = g_byte_array_new();
          g_byte_array_append (this_object->auth_msk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_auth_msk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->attr_pk != NULL)
          {
            g_free(this_object->attr_pk);
            this_object->attr_pk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->attr_pk = g_byte_array_new();
          g_byte_array_append (this_object->attr_pk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_attr_pk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->attr_msk != NULL)
          {
            g_free(this_object->attr_msk);
            this_object->attr_msk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->attr_msk = g_byte_array_new();
          g_byte_array_append (this_object->attr_msk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_attr_msk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->attribute != NULL)
          {
            g_free(this_object->attribute);
            this_object->attribute = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->attribute, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_attribute = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_authority_updatekey_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthorityUpdatekeyArgs * this_object = AA_AUTHORITY_UPDATEKEY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorityUpdatekeyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "auth_msk", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->auth_msk ? ((GByteArray *) this_object->auth_msk)->data : NULL, this_object->auth_msk ? ((GByteArray *) this_object->auth_msk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_pk", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->attr_pk ? ((GByteArray *) this_object->attr_pk)->data : NULL, this_object->attr_pk ? ((GByteArray *) this_object->attr_pk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_msk", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->attr_msk ? ((GByteArray *) this_object->attr_msk)->data : NULL, this_object->attr_msk ? ((GByteArray *) this_object->attr_msk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attribute", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->attribute, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_authority_updatekey_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  aaAuthorityUpdatekeyArgs *self = AA_AUTHORITY_UPDATEKEY_ARGS (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_AUTH_MSK:
      if (self->auth_msk != NULL)
        g_byte_array_unref (self->auth_msk);
      self->auth_msk = g_value_dup_boxed (value);
      self->__isset_auth_msk = TRUE;
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_PK:
      if (self->attr_pk != NULL)
        g_byte_array_unref (self->attr_pk);
      self->attr_pk = g_value_dup_boxed (value);
      self->__isset_attr_pk = TRUE;
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_MSK:
      if (self->attr_msk != NULL)
        g_byte_array_unref (self->attr_msk);
      self->attr_msk = g_value_dup_boxed (value);
      self->__isset_attr_msk = TRUE;
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTRIBUTE:
      if (self->attribute != NULL)
        g_free (self->attribute);
      self->attribute = g_value_dup_string (value);
      self->__isset_attribute = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_authority_updatekey_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  aaAuthorityUpdatekeyArgs *self = AA_AUTHORITY_UPDATEKEY_ARGS (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_AUTH_MSK:
      g_value_set_boxed (value, self->auth_msk);
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_PK:
      g_value_set_boxed (value, self->attr_pk);
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_MSK:
      g_value_set_boxed (value, self->attr_msk);
      break;

    case PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTRIBUTE:
      g_value_set_string (value, self->attribute);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_authority_updatekey_args_instance_init (aaAuthorityUpdatekeyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->auth_msk = NULL;
  object->__isset_auth_msk = FALSE;
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->attr_pk = NULL;
  object->__isset_attr_pk = FALSE;
  object->attr_msk = NULL;
  object->__isset_attr_msk = FALSE;
  object->attribute = NULL;
  object->__isset_attribute = FALSE;
}

static void 
aa_authority_updatekey_args_finalize (GObject *object)
{
  aaAuthorityUpdatekeyArgs *tobject = AA_AUTHORITY_UPDATEKEY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->auth_msk != NULL)
  {
    thrift_string_free(tobject->auth_msk);
    tobject->auth_msk = NULL;
  }
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->attr_pk != NULL)
  {
    thrift_string_free(tobject->attr_pk);
    tobject->attr_pk = NULL;
  }
  if (tobject->attr_msk != NULL)
  {
    thrift_string_free(tobject->attr_msk);
    tobject->attr_msk = NULL;
  }
  if (tobject->attribute != NULL)
  {
    g_free(tobject->attribute);
    tobject->attribute = NULL;
  }
}

static void
aa_authority_updatekey_args_class_init (aaAuthorityUpdatekeyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_authority_updatekey_args_read;
  struct_class->write = aa_authority_updatekey_args_write;

  gobject_class->finalize = aa_authority_updatekey_args_finalize;
  gobject_class->get_property = aa_authority_updatekey_args_get_property;
  gobject_class->set_property = aa_authority_updatekey_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_UPDATEKEY_ARGS_AUTH_MSK,
     g_param_spec_boxed ("auth_msk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_UPDATEKEY_ARGS_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_PK,
     g_param_spec_boxed ("attr_pk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTR_MSK,
     g_param_spec_boxed ("attr_msk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_UPDATEKEY_ARGS_ATTRIBUTE,
     g_param_spec_string ("attribute",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
aa_authority_updatekey_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthorityUpdatekeyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_authority_updatekey_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthorityUpdatekeyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_authority_updatekey_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthorityUpdatekeyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _aaAuthorityUpdatekeyResultProperties
{
  PROP_AA_AUTHORITY_UPDATEKEY_RESULT_0,
  PROP_AA_AUTHORITY_UPDATEKEY_RESULT_SUCCESS
};

/* reads a authority_updatekey_result object */
static gint32
aa_authority_updatekey_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  aaAuthorityUpdatekeyResult * this_object = AA_AUTHORITY_UPDATEKEY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aa_authority_updatekey_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  aaAuthorityUpdatekeyResult * this_object = AA_AUTHORITY_UPDATEKEY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthorityUpdatekeyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aa_authority_updatekey_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  aaAuthorityUpdatekeyResult *self = AA_AUTHORITY_UPDATEKEY_RESULT (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_UPDATEKEY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aa_authority_updatekey_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  aaAuthorityUpdatekeyResult *self = AA_AUTHORITY_UPDATEKEY_RESULT (object);

  switch (property_id)
  {
    case PROP_AA_AUTHORITY_UPDATEKEY_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aa_authority_updatekey_result_instance_init (aaAuthorityUpdatekeyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (AA_TYPE_ATTR_PAIR, NULL);
  object->__isset_success = FALSE;
}

static void 
aa_authority_updatekey_result_finalize (GObject *object)
{
  aaAuthorityUpdatekeyResult *tobject = AA_AUTHORITY_UPDATEKEY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
aa_authority_updatekey_result_class_init (aaAuthorityUpdatekeyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aa_authority_updatekey_result_read;
  struct_class->write = aa_authority_updatekey_result_write;

  gobject_class->finalize = aa_authority_updatekey_result_finalize;
  gobject_class->get_property = aa_authority_updatekey_result_get_property;
  gobject_class->set_property = aa_authority_updatekey_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AA_AUTHORITY_UPDATEKEY_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         AA_TYPE_ATTR_PAIR,
                         G_PARAM_READWRITE));
}

GType
aa_authority_updatekey_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (aaAuthorityUpdatekeyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aa_authority_updatekey_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (aaAuthorityUpdatekeyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) aa_authority_updatekey_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "aaAuthorityUpdatekeyResultType",
                                   &type_info, 0);
  }

  return type;
}

