/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "policy_policy_types.h"
#include <thrift/c_glib/thrift.h>

/* constants */

enum _policyPolicyParseAttributesArgsProperties
{
  PROP_POLICY_POLICY_PARSE_ATTRIBUTES_ARGS_0,
  PROP_POLICY_POLICY_PARSE_ATTRIBUTES_ARGS_ATTRIBUTE
};

/* reads a policy_parse_attributes_args object */
static gint32
policy_policy_parse_attributes_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  policyPolicyParseAttributesArgs * this_object = POLICY_POLICY_PARSE_ATTRIBUTES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->attribute != NULL)
          {
            g_free(this_object->attribute);
            this_object->attribute = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->attribute, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_attribute = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
policy_policy_parse_attributes_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  policyPolicyParseAttributesArgs * this_object = POLICY_POLICY_PARSE_ATTRIBUTES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PolicyParseAttributesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attribute", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->attribute, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
policy_policy_parse_attributes_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  policyPolicyParseAttributesArgs *self = POLICY_POLICY_PARSE_ATTRIBUTES_ARGS (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_ATTRIBUTES_ARGS_ATTRIBUTE:
      if (self->attribute != NULL)
        g_free (self->attribute);
      self->attribute = g_value_dup_string (value);
      self->__isset_attribute = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
policy_policy_parse_attributes_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  policyPolicyParseAttributesArgs *self = POLICY_POLICY_PARSE_ATTRIBUTES_ARGS (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_ATTRIBUTES_ARGS_ATTRIBUTE:
      g_value_set_string (value, self->attribute);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
policy_policy_parse_attributes_args_instance_init (policyPolicyParseAttributesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->attribute = NULL;
  object->__isset_attribute = FALSE;
}

static void 
policy_policy_parse_attributes_args_finalize (GObject *object)
{
  policyPolicyParseAttributesArgs *tobject = POLICY_POLICY_PARSE_ATTRIBUTES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->attribute != NULL)
  {
    g_free(tobject->attribute);
    tobject->attribute = NULL;
  }
}

static void
policy_policy_parse_attributes_args_class_init (policyPolicyParseAttributesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = policy_policy_parse_attributes_args_read;
  struct_class->write = policy_policy_parse_attributes_args_write;

  gobject_class->finalize = policy_policy_parse_attributes_args_finalize;
  gobject_class->get_property = policy_policy_parse_attributes_args_get_property;
  gobject_class->set_property = policy_policy_parse_attributes_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_POLICY_POLICY_PARSE_ATTRIBUTES_ARGS_ATTRIBUTE,
     g_param_spec_string ("attribute",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
policy_policy_parse_attributes_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (policyPolicyParseAttributesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) policy_policy_parse_attributes_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (policyPolicyParseAttributesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) policy_policy_parse_attributes_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "policyPolicyParseAttributesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _policyPolicyParseAttributesResultProperties
{
  PROP_POLICY_POLICY_PARSE_ATTRIBUTES_RESULT_0,
  PROP_POLICY_POLICY_PARSE_ATTRIBUTES_RESULT_SUCCESS
};

/* reads a policy_parse_attributes_result object */
static gint32
policy_policy_parse_attributes_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  policyPolicyParseAttributesResult * this_object = POLICY_POLICY_PARSE_ATTRIBUTES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem0 = NULL;
              if (_elem0 != NULL)
              {
                g_free(_elem0);
                _elem0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
policy_policy_parse_attributes_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  policyPolicyParseAttributesResult * this_object = POLICY_POLICY_PARSE_ATTRIBUTES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PolicyParseAttributesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i1;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i1 = 0; i1 < (this_object->success ? this_object->success->len : 0); i1++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i1)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
policy_policy_parse_attributes_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  policyPolicyParseAttributesResult *self = POLICY_POLICY_PARSE_ATTRIBUTES_RESULT (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_ATTRIBUTES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
policy_policy_parse_attributes_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  policyPolicyParseAttributesResult *self = POLICY_POLICY_PARSE_ATTRIBUTES_RESULT (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_ATTRIBUTES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
policy_policy_parse_attributes_result_instance_init (policyPolicyParseAttributesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
}

static void 
policy_policy_parse_attributes_result_finalize (GObject *object)
{
  policyPolicyParseAttributesResult *tobject = POLICY_POLICY_PARSE_ATTRIBUTES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
policy_policy_parse_attributes_result_class_init (policyPolicyParseAttributesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = policy_policy_parse_attributes_result_read;
  struct_class->write = policy_policy_parse_attributes_result_write;

  gobject_class->finalize = policy_policy_parse_attributes_result_finalize;
  gobject_class->get_property = policy_policy_parse_attributes_result_get_property;
  gobject_class->set_property = policy_policy_parse_attributes_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_POLICY_POLICY_PARSE_ATTRIBUTES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
policy_policy_parse_attributes_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (policyPolicyParseAttributesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) policy_policy_parse_attributes_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (policyPolicyParseAttributesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) policy_policy_parse_attributes_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "policyPolicyParseAttributesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _policyPolicyParsePolicyArgsProperties
{
  PROP_POLICY_POLICY_PARSE_POLICY_ARGS_0,
  PROP_POLICY_POLICY_PARSE_POLICY_ARGS_POLICY
};

/* reads a policy_parse_policy_args object */
static gint32
policy_policy_parse_policy_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  policyPolicyParsePolicyArgs * this_object = POLICY_POLICY_PARSE_POLICY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->policy != NULL)
          {
            g_free(this_object->policy);
            this_object->policy = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->policy, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_policy = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
policy_policy_parse_policy_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  policyPolicyParsePolicyArgs * this_object = POLICY_POLICY_PARSE_POLICY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PolicyParsePolicyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "policy", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->policy, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
policy_policy_parse_policy_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  policyPolicyParsePolicyArgs *self = POLICY_POLICY_PARSE_POLICY_ARGS (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_POLICY_ARGS_POLICY:
      if (self->policy != NULL)
        g_free (self->policy);
      self->policy = g_value_dup_string (value);
      self->__isset_policy = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
policy_policy_parse_policy_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  policyPolicyParsePolicyArgs *self = POLICY_POLICY_PARSE_POLICY_ARGS (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_POLICY_ARGS_POLICY:
      g_value_set_string (value, self->policy);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
policy_policy_parse_policy_args_instance_init (policyPolicyParsePolicyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->policy = NULL;
  object->__isset_policy = FALSE;
}

static void 
policy_policy_parse_policy_args_finalize (GObject *object)
{
  policyPolicyParsePolicyArgs *tobject = POLICY_POLICY_PARSE_POLICY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->policy != NULL)
  {
    g_free(tobject->policy);
    tobject->policy = NULL;
  }
}

static void
policy_policy_parse_policy_args_class_init (policyPolicyParsePolicyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = policy_policy_parse_policy_args_read;
  struct_class->write = policy_policy_parse_policy_args_write;

  gobject_class->finalize = policy_policy_parse_policy_args_finalize;
  gobject_class->get_property = policy_policy_parse_policy_args_get_property;
  gobject_class->set_property = policy_policy_parse_policy_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_POLICY_POLICY_PARSE_POLICY_ARGS_POLICY,
     g_param_spec_string ("policy",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
policy_policy_parse_policy_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (policyPolicyParsePolicyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) policy_policy_parse_policy_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (policyPolicyParsePolicyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) policy_policy_parse_policy_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "policyPolicyParsePolicyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _policyPolicyParsePolicyResultProperties
{
  PROP_POLICY_POLICY_PARSE_POLICY_RESULT_0,
  PROP_POLICY_POLICY_PARSE_POLICY_RESULT_SUCCESS
};

/* reads a policy_parse_policy_result object */
static gint32
policy_policy_parse_policy_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  policyPolicyParsePolicyResult * this_object = POLICY_POLICY_PARSE_POLICY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
policy_policy_parse_policy_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  policyPolicyParsePolicyResult * this_object = POLICY_POLICY_PARSE_POLICY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PolicyParsePolicyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
policy_policy_parse_policy_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  policyPolicyParsePolicyResult *self = POLICY_POLICY_PARSE_POLICY_RESULT (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_POLICY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
policy_policy_parse_policy_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  policyPolicyParsePolicyResult *self = POLICY_POLICY_PARSE_POLICY_RESULT (object);

  switch (property_id)
  {
    case PROP_POLICY_POLICY_PARSE_POLICY_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
policy_policy_parse_policy_result_instance_init (policyPolicyParsePolicyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
policy_policy_parse_policy_result_finalize (GObject *object)
{
  policyPolicyParsePolicyResult *tobject = POLICY_POLICY_PARSE_POLICY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
policy_policy_parse_policy_result_class_init (policyPolicyParsePolicyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = policy_policy_parse_policy_result_read;
  struct_class->write = policy_policy_parse_policy_result_write;

  gobject_class->finalize = policy_policy_parse_policy_result_finalize;
  gobject_class->get_property = policy_policy_parse_policy_result_get_property;
  gobject_class->set_property = policy_policy_parse_policy_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_POLICY_POLICY_PARSE_POLICY_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
policy_policy_parse_policy_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (policyPolicyParsePolicyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) policy_policy_parse_policy_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (policyPolicyParsePolicyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) policy_policy_parse_policy_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "policyPolicyParsePolicyResultType",
                                   &type_info, 0);
  }

  return type;
}

