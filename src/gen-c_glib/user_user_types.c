/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "user_user_types.h"
#include <thrift/c_glib/thrift.h>

enum _userUserPrvKeyProperties
{
  PROP_USER_USER_PRV_KEY_0,
  PROP_USER_USER_PRV_KEY_AIDS,
  PROP_USER_USER_PRV_KEY_GPK,
  PROP_USER_USER_PRV_KEY_GSK,
  PROP_USER_USER_PRV_KEY_CERT,
  PROP_USER_USER_PRV_KEY_SKS,
  PROP_USER_USER_PRV_KEY_CASK,
  PROP_USER_USER_PRV_KEY_ATTRIBUTES
};

/* reads a user_prv_key object */
static gint32
user_user_prv_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  userUserPrvKey * this_object = USER_USER_PRV_KEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem0 = NULL;
              if (_elem0 != NULL)
              {
                g_free(_elem0);
                _elem0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->aids, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_aids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->gpk != NULL)
          {
            g_free(this_object->gpk);
            this_object->gpk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->gpk = g_byte_array_new();
          g_byte_array_append (this_object->gpk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_gpk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->gsk != NULL)
          {
            g_free(this_object->gsk);
            this_object->gsk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->gsk = g_byte_array_new();
          g_byte_array_append (this_object->gsk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_gsk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->cert != NULL)
          {
            g_free(this_object->cert);
            this_object->cert = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->cert = g_byte_array_new();
          g_byte_array_append (this_object->cert, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_cert = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key1 = NULL;
              aaARevoKey * val2 = NULL;
              if (key1 != NULL)
              {
                g_free(key1);
                key1 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key1, error)) < 0)
                return -1;
              xfer += ret;
              if ( val2 != NULL)
              {
                g_object_unref (val2);
              }
              val2 = g_object_new (AA_TYPE_A_REVO_KEY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val2), protocol, error)) < 0)
              {
                g_object_unref (val2);
                return -1;
              }
              xfer += ret;
              if (this_object->sks && key1)
                g_hash_table_insert ((GHashTable *)this_object->sks, (gpointer) key1, (gpointer) val2);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_sks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cask), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cask = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem3 = NULL;
              if (_elem3 != NULL)
              {
                g_free(_elem3);
                _elem3 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem3, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_user_prv_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  userUserPrvKey * this_object = USER_USER_PRV_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserPrvKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aids", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->aids ? this_object->aids->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < (this_object->aids ? this_object->aids->len : 0); i4++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->aids, i4)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "gpk", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->gpk ? ((GByteArray *) this_object->gpk)->data : NULL, this_object->gpk ? ((GByteArray *) this_object->gpk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "gsk", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->gsk ? ((GByteArray *) this_object->gsk)->data : NULL, this_object->gsk ? ((GByteArray *) this_object->gsk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cert", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->cert ? ((GByteArray *) this_object->cert)->data : NULL, this_object->cert ? ((GByteArray *) this_object->cert)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sks", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key5 = NULL;
    aaARevoKey * val6 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->sks ? (gint32) g_hash_table_size ((GHashTable *) this_object->sks) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->sks)
      g_hash_table_foreach ((GHashTable *) this_object->sks, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key5 = keys[i];
      val6 = (aaARevoKey *) g_hash_table_lookup (((GHashTable *) this_object->sks), (gpointer) key5);

      if ((ret = thrift_protocol_write_string (protocol,  key5, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val6), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cask", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cask), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i7;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i7 = 0; i7 < (this_object->attributes ? this_object->attributes->len : 0); i7++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i7)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_user_prv_key_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  userUserPrvKey *self = USER_USER_PRV_KEY (object);

  switch (property_id)
  {
    case PROP_USER_USER_PRV_KEY_AIDS:
      if (self->aids != NULL)
        g_ptr_array_unref (self->aids);
      self->aids = g_value_dup_boxed (value);
      self->__isset_aids = TRUE;
      break;

    case PROP_USER_USER_PRV_KEY_GPK:
      if (self->gpk != NULL)
        g_byte_array_unref (self->gpk);
      self->gpk = g_value_dup_boxed (value);
      self->__isset_gpk = TRUE;
      break;

    case PROP_USER_USER_PRV_KEY_GSK:
      if (self->gsk != NULL)
        g_byte_array_unref (self->gsk);
      self->gsk = g_value_dup_boxed (value);
      self->__isset_gsk = TRUE;
      break;

    case PROP_USER_USER_PRV_KEY_CERT:
      if (self->cert != NULL)
        g_byte_array_unref (self->cert);
      self->cert = g_value_dup_boxed (value);
      self->__isset_cert = TRUE;
      break;

    case PROP_USER_USER_PRV_KEY_SKS:
      if (self->sks != NULL)
        g_hash_table_unref (self->sks);
      self->sks = g_value_dup_boxed (value);
      self->__isset_sks = TRUE;
      break;

    case PROP_USER_USER_PRV_KEY_CASK:
      if (self->cask != NULL)
        g_object_unref (self->cask);
      self->cask = g_value_dup_object (value);
      self->__isset_cask = TRUE;
      break;

    case PROP_USER_USER_PRV_KEY_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_user_prv_key_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  userUserPrvKey *self = USER_USER_PRV_KEY (object);

  switch (property_id)
  {
    case PROP_USER_USER_PRV_KEY_AIDS:
      g_value_set_boxed (value, self->aids);
      break;

    case PROP_USER_USER_PRV_KEY_GPK:
      g_value_set_boxed (value, self->gpk);
      break;

    case PROP_USER_USER_PRV_KEY_GSK:
      g_value_set_boxed (value, self->gsk);
      break;

    case PROP_USER_USER_PRV_KEY_CERT:
      g_value_set_boxed (value, self->cert);
      break;

    case PROP_USER_USER_PRV_KEY_SKS:
      g_value_set_boxed (value, self->sks);
      break;

    case PROP_USER_USER_PRV_KEY_CASK:
      g_value_set_object (value, self->cask);
      break;

    case PROP_USER_USER_PRV_KEY_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_user_prv_key_instance_init (userUserPrvKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aids = g_ptr_array_new_with_free_func (g_free);
  object->__isset_aids = FALSE;
  object->gpk = NULL;
  object->__isset_gpk = FALSE;
  object->gsk = NULL;
  object->__isset_gsk = FALSE;
  object->cert = NULL;
  object->__isset_cert = FALSE;
  object->sks = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_sks = FALSE;
  object->cask = g_object_new (CA_TYPE_U_REVO_KEY, NULL);
  object->__isset_cask = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
}

static void 
user_user_prv_key_finalize (GObject *object)
{
  userUserPrvKey *tobject = USER_USER_PRV_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aids != NULL)
  {
    g_ptr_array_unref (tobject->aids);
    tobject->aids = NULL;
  }
  if (tobject->gpk != NULL)
  {
    thrift_string_free(tobject->gpk);
    tobject->gpk = NULL;
  }
  if (tobject->gsk != NULL)
  {
    thrift_string_free(tobject->gsk);
    tobject->gsk = NULL;
  }
  if (tobject->cert != NULL)
  {
    thrift_string_free(tobject->cert);
    tobject->cert = NULL;
  }
  if (tobject->sks != NULL)
  {
    g_hash_table_destroy (tobject->sks);
    tobject->sks = NULL;
  }
  if (tobject->cask != NULL)
  {
    g_object_unref(tobject->cask);
    tobject->cask = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
user_user_prv_key_class_init (userUserPrvKeyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_user_prv_key_read;
  struct_class->write = user_user_prv_key_write;

  gobject_class->finalize = user_user_prv_key_finalize;
  gobject_class->get_property = user_user_prv_key_get_property;
  gobject_class->set_property = user_user_prv_key_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_AIDS,
     g_param_spec_boxed ("aids",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_GPK,
     g_param_spec_boxed ("gpk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_GSK,
     g_param_spec_boxed ("gsk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_CERT,
     g_param_spec_boxed ("cert",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_SKS,
     g_param_spec_boxed ("sks",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_CASK,
     g_param_spec_object ("cask",
                         NULL,
                         NULL,
                         CA_TYPE_U_REVO_KEY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_PRV_KEY_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
user_user_prv_key_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (userUserPrvKeyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_user_prv_key_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (userUserPrvKey),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_user_prv_key_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "userUserPrvKeyType",
                                   &type_info, 0);
  }

  return type;
}

enum _userAuthPKProperties
{
  PROP_USER_AUTH_P_K_0,
  PROP_USER_AUTH_P_K_AID,
  PROP_USER_AUTH_P_K_PK,
  PROP_USER_AUTH_P_K_ATTR_PKS,
  PROP_USER_AUTH_P_K_ATTRIBUTES
};

/* reads a auth_p_k object */
static gint32
user_auth_p_k_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  userAuthPK * this_object = USER_AUTH_P_K(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aid != NULL)
          {
            g_free(this_object->aid);
            this_object->aid = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->aid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_aid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pk != NULL)
          {
            g_free(this_object->pk);
            this_object->pk = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pk = g_byte_array_new();
          g_byte_array_append (this_object->pk, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pk = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key8 = NULL;
              GByteArray * val9 = NULL;
              if (key8 != NULL)
              {
                g_free(key8);
                key8 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key8, error)) < 0)
                return -1;
              xfer += ret;
              if (val9 != NULL)
              {
                g_free(val9);
                val9 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              val9 = g_byte_array_new();
              g_byte_array_append (val9, (guint8 *) data, (guint) len);
              g_free (data);
              if (this_object->attr_pks && key8)
                g_hash_table_insert ((GHashTable *)this_object->attr_pks, (gpointer) key8, (gpointer) val9);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attr_pks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem10 = NULL;
              if (_elem10 != NULL)
              {
                g_free(_elem10);
                _elem10 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem10, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->attributes, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attributes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_auth_p_k_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  userAuthPK * this_object = USER_AUTH_P_K(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AuthPK", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aid", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->aid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pk", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pk ? ((GByteArray *) this_object->pk)->data : NULL, this_object->pk ? ((GByteArray *) this_object->pk)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_pks", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key11 = NULL;
    GByteArray * val12 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->attr_pks ? (gint32) g_hash_table_size ((GHashTable *) this_object->attr_pks) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->attr_pks)
      g_hash_table_foreach ((GHashTable *) this_object->attr_pks, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key11 = keys[i];
      val12 = (GByteArray *) g_hash_table_lookup (((GHashTable *) this_object->attr_pks), (gpointer) key11);

      if ((ret = thrift_protocol_write_string (protocol,  key11, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_binary (protocol,  val12 ? ((GByteArray *)  val12)->data : NULL,  val12 ? ((GByteArray *)  val12)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attributes", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->attributes ? this_object->attributes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < (this_object->attributes ? this_object->attributes->len : 0); i13++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->attributes, i13)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_auth_p_k_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  userAuthPK *self = USER_AUTH_P_K (object);

  switch (property_id)
  {
    case PROP_USER_AUTH_P_K_AID:
      if (self->aid != NULL)
        g_free (self->aid);
      self->aid = g_value_dup_string (value);
      self->__isset_aid = TRUE;
      break;

    case PROP_USER_AUTH_P_K_PK:
      if (self->pk != NULL)
        g_byte_array_unref (self->pk);
      self->pk = g_value_dup_boxed (value);
      self->__isset_pk = TRUE;
      break;

    case PROP_USER_AUTH_P_K_ATTR_PKS:
      if (self->attr_pks != NULL)
        g_hash_table_unref (self->attr_pks);
      self->attr_pks = g_value_dup_boxed (value);
      self->__isset_attr_pks = TRUE;
      break;

    case PROP_USER_AUTH_P_K_ATTRIBUTES:
      if (self->attributes != NULL)
        g_ptr_array_unref (self->attributes);
      self->attributes = g_value_dup_boxed (value);
      self->__isset_attributes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_auth_p_k_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  userAuthPK *self = USER_AUTH_P_K (object);

  switch (property_id)
  {
    case PROP_USER_AUTH_P_K_AID:
      g_value_set_string (value, self->aid);
      break;

    case PROP_USER_AUTH_P_K_PK:
      g_value_set_boxed (value, self->pk);
      break;

    case PROP_USER_AUTH_P_K_ATTR_PKS:
      g_value_set_boxed (value, self->attr_pks);
      break;

    case PROP_USER_AUTH_P_K_ATTRIBUTES:
      g_value_set_boxed (value, self->attributes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_auth_p_k_instance_init (userAuthPK * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aid = NULL;
  object->__isset_aid = FALSE;
  object->pk = NULL;
  object->__isset_pk = FALSE;
  object->attr_pks = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, thrift_string_free);
  object->__isset_attr_pks = FALSE;
  object->attributes = g_ptr_array_new_with_free_func (g_free);
  object->__isset_attributes = FALSE;
}

static void 
user_auth_p_k_finalize (GObject *object)
{
  userAuthPK *tobject = USER_AUTH_P_K (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aid != NULL)
  {
    g_free(tobject->aid);
    tobject->aid = NULL;
  }
  if (tobject->pk != NULL)
  {
    thrift_string_free(tobject->pk);
    tobject->pk = NULL;
  }
  if (tobject->attr_pks != NULL)
  {
    g_hash_table_destroy (tobject->attr_pks);
    tobject->attr_pks = NULL;
  }
  if (tobject->attributes != NULL)
  {
    g_ptr_array_unref (tobject->attributes);
    tobject->attributes = NULL;
  }
}

static void
user_auth_p_k_class_init (userAuthPKClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_auth_p_k_read;
  struct_class->write = user_auth_p_k_write;

  gobject_class->finalize = user_auth_p_k_finalize;
  gobject_class->get_property = user_auth_p_k_get_property;
  gobject_class->set_property = user_auth_p_k_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_AUTH_P_K_AID,
     g_param_spec_string ("aid",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_AUTH_P_K_PK,
     g_param_spec_boxed ("pk",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_AUTH_P_K_ATTR_PKS,
     g_param_spec_boxed ("attr_pks",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_AUTH_P_K_ATTRIBUTES,
     g_param_spec_boxed ("attributes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
user_auth_p_k_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (userAuthPKClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_auth_p_k_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (userAuthPK),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_auth_p_k_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "userAuthPKType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _userUserEncryptArgsProperties
{
  PROP_USER_USER_ENCRYPT_ARGS_0,
  PROP_USER_USER_ENCRYPT_ARGS_PUB,
  PROP_USER_USER_ENCRYPT_ARGS_ATTR_PKS,
  PROP_USER_USER_ENCRYPT_ARGS_POLICY,
  PROP_USER_USER_ENCRYPT_ARGS_REVO_LIST,
  PROP_USER_USER_ENCRYPT_ARGS_UINDEX,
  PROP_USER_USER_ENCRYPT_ARGS_MES
};

/* reads a user_encrypt_args object */
static gint32
user_user_encrypt_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  userUserEncryptArgs * this_object = USER_USER_ENCRYPT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              userAuthPK * _elem14 = NULL;
              if ( _elem14 != NULL)
              {
                g_object_unref (_elem14);
              }
              _elem14 = g_object_new (USER_TYPE_AUTH_P_K, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem14), protocol, error)) < 0)
              {
                g_object_unref (_elem14);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->attr_pks, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attr_pks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->policy != NULL)
          {
            g_free(this_object->policy);
            this_object->policy = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->policy, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_policy = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem15 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem15, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->revo_list, _elem15, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_revo_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->uindex, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_uindex = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->mes != NULL)
          {
            g_free(this_object->mes);
            this_object->mes = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->mes = g_byte_array_new();
          g_byte_array_append (this_object->mes, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_mes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_user_encrypt_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  userUserEncryptArgs * this_object = USER_USER_ENCRYPT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserEncryptArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_pks", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i16;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->attr_pks ? this_object->attr_pks->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i16 = 0; i16 < (this_object->attr_pks ? this_object->attr_pks->len : 0); i16++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->attr_pks, i16))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "policy", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->policy, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "revo_list", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i17;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->revo_list ? this_object->revo_list->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i17 = 0; i17 < (this_object->revo_list ? this_object->revo_list->len : 0); i17++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->revo_list, gint32, i17)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uindex", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->uindex, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mes", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->mes ? ((GByteArray *) this_object->mes)->data : NULL, this_object->mes ? ((GByteArray *) this_object->mes)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_user_encrypt_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  userUserEncryptArgs *self = USER_USER_ENCRYPT_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_USER_ENCRYPT_ARGS_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_ATTR_PKS:
      if (self->attr_pks != NULL)
        g_ptr_array_unref (self->attr_pks);
      self->attr_pks = g_value_dup_boxed (value);
      self->__isset_attr_pks = TRUE;
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_POLICY:
      if (self->policy != NULL)
        g_free (self->policy);
      self->policy = g_value_dup_string (value);
      self->__isset_policy = TRUE;
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_REVO_LIST:
      if (self->revo_list != NULL)
        g_array_unref (self->revo_list);
      self->revo_list = g_value_dup_boxed (value);
      self->__isset_revo_list = TRUE;
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_UINDEX:
      self->uindex = g_value_get_int (value);
      self->__isset_uindex = TRUE;
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_MES:
      if (self->mes != NULL)
        g_byte_array_unref (self->mes);
      self->mes = g_value_dup_boxed (value);
      self->__isset_mes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_user_encrypt_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  userUserEncryptArgs *self = USER_USER_ENCRYPT_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_USER_ENCRYPT_ARGS_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_ATTR_PKS:
      g_value_set_boxed (value, self->attr_pks);
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_POLICY:
      g_value_set_string (value, self->policy);
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_REVO_LIST:
      g_value_set_boxed (value, self->revo_list);
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_UINDEX:
      g_value_set_int (value, self->uindex);
      break;

    case PROP_USER_USER_ENCRYPT_ARGS_MES:
      g_value_set_boxed (value, self->mes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_user_encrypt_args_instance_init (userUserEncryptArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->attr_pks = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_attr_pks = FALSE;
  object->policy = NULL;
  object->__isset_policy = FALSE;
  object->revo_list = g_array_new (0, 1, sizeof (gint32));
  object->__isset_revo_list = FALSE;
  object->uindex = 0;
  object->__isset_uindex = FALSE;
  object->mes = NULL;
  object->__isset_mes = FALSE;
}

static void 
user_user_encrypt_args_finalize (GObject *object)
{
  userUserEncryptArgs *tobject = USER_USER_ENCRYPT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->attr_pks != NULL)
  {
    g_ptr_array_unref (tobject->attr_pks);
    tobject->attr_pks = NULL;
  }
  if (tobject->policy != NULL)
  {
    g_free(tobject->policy);
    tobject->policy = NULL;
  }
  if (tobject->revo_list != NULL)
  {
    g_array_unref (tobject->revo_list);
    tobject->revo_list = NULL;
  }
  if (tobject->mes != NULL)
  {
    thrift_string_free(tobject->mes);
    tobject->mes = NULL;
  }
}

static void
user_user_encrypt_args_class_init (userUserEncryptArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_user_encrypt_args_read;
  struct_class->write = user_user_encrypt_args_write;

  gobject_class->finalize = user_user_encrypt_args_finalize;
  gobject_class->get_property = user_user_encrypt_args_get_property;
  gobject_class->set_property = user_user_encrypt_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_ARGS_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_ARGS_ATTR_PKS,
     g_param_spec_boxed ("attr_pks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_ARGS_POLICY,
     g_param_spec_string ("policy",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_ARGS_REVO_LIST,
     g_param_spec_boxed ("revo_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_ARGS_UINDEX,
     g_param_spec_int ("uindex",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_ARGS_MES,
     g_param_spec_boxed ("mes",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
user_user_encrypt_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (userUserEncryptArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_user_encrypt_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (userUserEncryptArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_user_encrypt_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "userUserEncryptArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _userUserEncryptResultProperties
{
  PROP_USER_USER_ENCRYPT_RESULT_0,
  PROP_USER_USER_ENCRYPT_RESULT_SUCCESS
};

/* reads a user_encrypt_result object */
static gint32
user_user_encrypt_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  userUserEncryptResult * this_object = USER_USER_ENCRYPT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_user_encrypt_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  userUserEncryptResult * this_object = USER_USER_ENCRYPT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserEncryptResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_user_encrypt_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  userUserEncryptResult *self = USER_USER_ENCRYPT_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_USER_ENCRYPT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_user_encrypt_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  userUserEncryptResult *self = USER_USER_ENCRYPT_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_USER_ENCRYPT_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_user_encrypt_result_instance_init (userUserEncryptResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
user_user_encrypt_result_finalize (GObject *object)
{
  userUserEncryptResult *tobject = USER_USER_ENCRYPT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
user_user_encrypt_result_class_init (userUserEncryptResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_user_encrypt_result_read;
  struct_class->write = user_user_encrypt_result_write;

  gobject_class->finalize = user_user_encrypt_result_finalize;
  gobject_class->get_property = user_user_encrypt_result_get_property;
  gobject_class->set_property = user_user_encrypt_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_ENCRYPT_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
user_user_encrypt_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (userUserEncryptResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_user_encrypt_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (userUserEncryptResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_user_encrypt_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "userUserEncryptResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _userUserDecryptArgsProperties
{
  PROP_USER_USER_DECRYPT_ARGS_0,
  PROP_USER_USER_DECRYPT_ARGS_CPH,
  PROP_USER_USER_DECRYPT_ARGS_PUB,
  PROP_USER_USER_DECRYPT_ARGS_PRV
};

/* reads a user_decrypt_args object */
static gint32
user_user_decrypt_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  userUserDecryptArgs * this_object = USER_USER_DECRYPT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->cph != NULL)
          {
            g_free(this_object->cph);
            this_object->cph = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->cph = g_byte_array_new();
          g_byte_array_append (this_object->cph, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_cph = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->pub != NULL)
          {
            g_free(this_object->pub);
            this_object->pub = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->pub = g_byte_array_new();
          g_byte_array_append (this_object->pub, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_pub = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->prv), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_prv = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_user_decrypt_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  userUserDecryptArgs * this_object = USER_USER_DECRYPT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserDecryptArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cph", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->cph ? ((GByteArray *) this_object->cph)->data : NULL, this_object->cph ? ((GByteArray *) this_object->cph)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "pub", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->pub ? ((GByteArray *) this_object->pub)->data : NULL, this_object->pub ? ((GByteArray *) this_object->pub)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prv", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->prv), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_user_decrypt_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  userUserDecryptArgs *self = USER_USER_DECRYPT_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_USER_DECRYPT_ARGS_CPH:
      if (self->cph != NULL)
        g_byte_array_unref (self->cph);
      self->cph = g_value_dup_boxed (value);
      self->__isset_cph = TRUE;
      break;

    case PROP_USER_USER_DECRYPT_ARGS_PUB:
      if (self->pub != NULL)
        g_byte_array_unref (self->pub);
      self->pub = g_value_dup_boxed (value);
      self->__isset_pub = TRUE;
      break;

    case PROP_USER_USER_DECRYPT_ARGS_PRV:
      if (self->prv != NULL)
        g_object_unref (self->prv);
      self->prv = g_value_dup_object (value);
      self->__isset_prv = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_user_decrypt_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  userUserDecryptArgs *self = USER_USER_DECRYPT_ARGS (object);

  switch (property_id)
  {
    case PROP_USER_USER_DECRYPT_ARGS_CPH:
      g_value_set_boxed (value, self->cph);
      break;

    case PROP_USER_USER_DECRYPT_ARGS_PUB:
      g_value_set_boxed (value, self->pub);
      break;

    case PROP_USER_USER_DECRYPT_ARGS_PRV:
      g_value_set_object (value, self->prv);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_user_decrypt_args_instance_init (userUserDecryptArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cph = NULL;
  object->__isset_cph = FALSE;
  object->pub = NULL;
  object->__isset_pub = FALSE;
  object->prv = g_object_new (USER_TYPE_USER_PRV_KEY, NULL);
  object->__isset_prv = FALSE;
}

static void 
user_user_decrypt_args_finalize (GObject *object)
{
  userUserDecryptArgs *tobject = USER_USER_DECRYPT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cph != NULL)
  {
    thrift_string_free(tobject->cph);
    tobject->cph = NULL;
  }
  if (tobject->pub != NULL)
  {
    thrift_string_free(tobject->pub);
    tobject->pub = NULL;
  }
  if (tobject->prv != NULL)
  {
    g_object_unref(tobject->prv);
    tobject->prv = NULL;
  }
}

static void
user_user_decrypt_args_class_init (userUserDecryptArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_user_decrypt_args_read;
  struct_class->write = user_user_decrypt_args_write;

  gobject_class->finalize = user_user_decrypt_args_finalize;
  gobject_class->get_property = user_user_decrypt_args_get_property;
  gobject_class->set_property = user_user_decrypt_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_DECRYPT_ARGS_CPH,
     g_param_spec_boxed ("cph",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_DECRYPT_ARGS_PUB,
     g_param_spec_boxed ("pub",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_DECRYPT_ARGS_PRV,
     g_param_spec_object ("prv",
                         NULL,
                         NULL,
                         USER_TYPE_USER_PRV_KEY,
                         G_PARAM_READWRITE));
}

GType
user_user_decrypt_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (userUserDecryptArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_user_decrypt_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (userUserDecryptArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_user_decrypt_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "userUserDecryptArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _userUserDecryptResultProperties
{
  PROP_USER_USER_DECRYPT_RESULT_0,
  PROP_USER_USER_DECRYPT_RESULT_SUCCESS
};

/* reads a user_decrypt_result object */
static gint32
user_user_decrypt_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  userUserDecryptResult * this_object = USER_USER_DECRYPT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
user_user_decrypt_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  userUserDecryptResult * this_object = USER_USER_DECRYPT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UserDecryptResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
user_user_decrypt_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  userUserDecryptResult *self = USER_USER_DECRYPT_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_USER_DECRYPT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
user_user_decrypt_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  userUserDecryptResult *self = USER_USER_DECRYPT_RESULT (object);

  switch (property_id)
  {
    case PROP_USER_USER_DECRYPT_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
user_user_decrypt_result_instance_init (userUserDecryptResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
user_user_decrypt_result_finalize (GObject *object)
{
  userUserDecryptResult *tobject = USER_USER_DECRYPT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
user_user_decrypt_result_class_init (userUserDecryptResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = user_user_decrypt_result_read;
  struct_class->write = user_user_decrypt_result_write;

  gobject_class->finalize = user_user_decrypt_result_finalize;
  gobject_class->get_property = user_user_decrypt_result_get_property;
  gobject_class->set_property = user_user_decrypt_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_USER_USER_DECRYPT_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
user_user_decrypt_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (userUserDecryptResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) user_user_decrypt_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (userUserDecryptResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) user_user_decrypt_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "userUserDecryptResultType",
                                   &type_info, 0);
  }

  return type;
}

