
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <glib.h>
#include <glib-object.h>
#include <signal.h>

#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/protocol/thrift_binary_protocol_factory.h>
#include <thrift/c_glib/protocol/thrift_protocol_factory.h>
#include <thrift/c_glib/server/thrift_server.h>
#include <thrift/c_glib/server/thrift_simple_server.h>
#include <thrift/c_glib/transport/thrift_buffered_transport_factory.h>
#include <thrift/c_glib/transport/thrift_server_socket.h>
#include <thrift/c_glib/transport/thrift_server_transport.h>
#include <thrift/c_glib/protocol/thrift_compact_protocol_factory.h>
#include <thrift/c_glib/processor/thrift_multiplexed_processor.h>

// #include "gen-c_glib/calculator.h"
#include "authority.h"
#include "center.h"
#include "user.h"
#include "cloud.h"
#include "policy_service.h"

/* Our server object, declared globally so it is accessible within the
   SIGINT signal handler */
ThriftServer *server = NULL;

/* A flag that indicates whether the server was interrupted with
   SIGINT (i.e. Ctrl-C) so we can tell whether its termination was
   abnormal */
gboolean sigint_received = FALSE;

/* Handle SIGINT ("Ctrl-C") signals by gracefully stopping the
   server */
static void
sigint_handler (int signal_number)
{
  THRIFT_UNUSED_VAR (signal_number);

  /* Take note we were called */
  sigint_received = TRUE;

  /* Shut down the server gracefully */
  if (server != NULL)
    thrift_server_stop (server);
}

int main (void)
{
  // TutorialCalculatorHandler *handler;
  // CalculatorProcessor *processor;
  ThriftProcessor * processor;

  MainAaAuthorityHandler *handler;
  MainCaCenterHandler    *ca_handler;
  MainUserAuthorityHandler *user_handler;
  MainCloudHandler      *cloud_handler;
  MainPolicyHandler     *policy_handler;

  caCenterProcessor *ca_processor;
  aaAuthorityProcessor *aa_processor;
  userUserProcessor *user_processor;
  cloudCloudProcessor   *cloud_processor;
  policyPolicyProcessor *policy_processor;

  ThriftServerTransport *server_transport;
  ThriftTransportFactory *transport_factory;
  ThriftProtocolFactory *protocol_factory;

  struct sigaction sigint_action;

  GError *error = NULL;
  int exit_status = 0;

#if (!GLIB_CHECK_VERSION (2, 36, 0))
  g_type_init ();
#endif

   processor = g_object_new (THRIFT_TYPE_MULTIPLEXED_PROCESSOR,
                             NULL);

  /* Create an instance of our handler, which provides the service's
     methods' implementation */
  handler =
    g_object_new (TYPE_MAIN_AA_AUTHORITY_HANDLER,
                  NULL);
   
  ca_handler =
    g_object_new (TYPE_MAIN_CA_CENTER_HANDLER,
                  NULL);
  user_handler = 
    g_object_new (TYPE_MAIN_USER_AUTHORITY_HANDLER,
                  NULL);
  cloud_handler =
    g_object_new (TYPE_MAIN_CLOUD_HANDLER,
                  NULL);
  policy_handler = 
    g_object_new (TYPE_MAIN_POLICY_HANDLER,
                  NULL);
  /* Create an instance of the service's processor, automatically
     generated by the Thrift compiler, which parses incoming messages
     and dispatches them to the appropriate method in the handler */
  aa_processor =
    g_object_new (AA_TYPE_AUTHORITY_PROCESSOR,
                  "handler", handler,
                  NULL);
  ca_processor =
    g_object_new (CA_TYPE_CENTER_PROCESSOR,
                  "handler", ca_handler,
                  NULL);
  user_processor =
    g_object_new (USER_TYPE_USER_PROCESSOR,
                  "handler", user_handler,
                  NULL);
  cloud_processor = 
    g_object_new (CLOUD_TYPE_CLOUD_PROCESSOR,
                  "handler", cloud_handler,
                  NULL);
  
  policy_processor = 
    g_object_new (POLICY_TYPE_POLICY_PROCESSOR,
                  "handler", policy_handler,
                  NULL);
   
  if (!thrift_multiplexed_processor_register_processor(processor,
       "CENTER_AUTHORITY", ca_processor,
       &error))
  {
     g_message ("thrift_server_serve:%s",
                error!=NULL ? error->message:"(null)");
     g_clear_error(&error);
     error = NULL;
  }

  if (!thrift_multiplexed_processor_register_processor(processor,
      "ATTRIBUTE_AUTHORITY", aa_processor,
      &error))
  {
     g_message ("thrift_server_serve:%s",
                error!=NULL ? error->message:"(null)");
     g_clear_error(&error);
     error = NULL;
  }

  if (!thrift_multiplexed_processor_register_processor(processor,
      "USER_AUTHORITY", user_processor,
      &error))
  {
     g_message ("thrift_server_serve:%s",
                error!=NULL ? error->message:"(null)");
     g_clear_error(&error);
     error = NULL;
  }
  if (!thrift_multiplexed_processor_register_processor(processor,
      "CLOUD_AUTHORITY", cloud_processor,
      &error))
  {
     g_message ("thrift_server_serve:%s",
                error!=NULL ? error->message:"(null)");
     g_clear_error(&error);
     error = NULL;
  }

  if (!thrift_multiplexed_processor_register_processor(processor,
      "POLICY_AUTHORITY", policy_processor,
      &error))
  {
     g_message ("thrift_server_serve:%s",
                error!=NULL ? error->message:"(null)");
     g_clear_error(&error);
     error = NULL;
  }
  /* Create our server socket, which binds to the specified port and
     listens for client connections */
  server_transport =
    g_object_new (THRIFT_TYPE_SERVER_SOCKET,
                  "port", 9090,
                  NULL);

  /* Create our transport factory, used by the server to wrap "raw"
     incoming connections from the client (in this case with a
     ThriftBufferedTransport to improve performance) */
  transport_factory =
    g_object_new (THRIFT_TYPE_BUFFERED_TRANSPORT_FACTORY,
                  NULL);

  /* Create our protocol factory, which determines which wire protocol
     the server will use (in this case, Thrift's binary protocol) */
  protocol_factory =
    g_object_new (THRIFT_TYPE_BINARY_PROTOCOL_FACTORY,
                  NULL);

  /* Create the server itself */
  server =
    g_object_new (THRIFT_TYPE_SIMPLE_SERVER,
                  "processor",                processor,               "server_transport",         server_transport,
                  "input_transport_factory",  transport_factory,
                  "output_transport_factory", transport_factory,
                  "input_protocol_factory",   protocol_factory,
                  "output_protocol_factory",  protocol_factory,
                  NULL);

  /* Install our SIGINT handler, which handles Ctrl-C being pressed by
     stopping the server gracefully (not strictly necessary, but a
     nice touch) */
  memset (&sigint_action, 0, sizeof (sigint_action));
  sigint_action.sa_handler = sigint_handler;
  sigint_action.sa_flags = SA_RESETHAND;
  sigaction (SIGINT, &sigint_action, NULL);

  /* Start the server, which will run until its stop method is invoked
     (from within the SIGINT handler, in this case) */
  puts ("Starting the server...");
  thrift_server_serve (server, &error);

  /* If the server stopped for any reason other than having been
     interrupted by the user, report the error */
  if (!sigint_received) {
    g_message ("thrift_server_serve: %s",
               error != NULL ? error->message : "(null)");
    g_clear_error (&error);
  }

  puts ("done.");

  g_object_unref (server);
  g_object_unref (transport_factory);
  g_object_unref (protocol_factory);
  g_object_unref (server_transport);

  g_object_unref (processor);
  g_object_unref (handler);
  g_object_unref (ca_processor);
  g_object_unref (aa_processor);
  g_object_unref (ca_handler);
  g_object_unref (user_processor);
  g_object_unref (user_handler);
  g_object_unref (cloud_handler);
  g_object_unref (cloud_processor);
  g_object_unref (policy_handler);
  g_object_unref (policy_processor);


  return exit_status;
}
